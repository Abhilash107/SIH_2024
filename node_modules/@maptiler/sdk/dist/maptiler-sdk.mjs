var rt = Object.defineProperty;
var me = (r) => {
  throw TypeError(r);
};
var at = (r, e, t) => e in r ? rt(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var T = (r, e, t) => at(r, typeof e != "symbol" ? e + "" : e, t), re = (r, e, t) => e.has(r) || me("Cannot " + t);
var L = (r, e, t) => (re(r, e, "read from private field"), t ? t.call(r) : e.get(r)), D = (r, e, t) => e.has(r) ? me("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t), $ = (r, e, t, o) => (re(r, e, "write to private field"), o ? o.call(r, t) : e.set(r, t), t), P = (r, e, t) => (re(r, e, "access private method"), t);
import f from "maplibre-gl";
import nt from "events";
import { config as ae, MapStyle as lt, mapStylePresetList as it, expandMapStyle as st, MapStyleVariant as ct, ReferenceMapStyle as ut, geolocation as fe } from "@maptiler/client";
import { LanguageGeocoding as Qr, MapStyle as ea, MapStyleVariant as ta, ReferenceMapStyle as oa, ServiceError as ra, bufferToPixelDataBrowser as aa, circumferenceAtLatitude as na, coordinates as la, data as ia, elevation as sa, expandMapStyle as ca, geocoding as ua, geolocation as pa, getAutoLanguageGeocoding as da, getBufferToPixelDataParser as ha, getTileCache as ma, mapStylePresetList as fa, math as ga, misc as ya, staticMaps as va, styleToStyle as La } from "@maptiler/client";
import { v4 as pt } from "uuid";
import { Base64 as dt } from "js-base64";
const ht = "@maptiler/sdk", mt = "2.2.2", ft = "The Javascript & TypeScript map SDK tailored for MapTiler Cloud", gt = "dist/maptiler-sdk.mjs", yt = "dist/maptiler-sdk.d.ts", vt = "dist/maptiler-sdk.css", Lt = "module", At = {
  ".": {
    import: "./dist/maptiler-sdk.mjs",
    types: "./dist/maptiler-sdk.d.ts"
  },
  "./dist/maptiler-sdk.css": {
    import: "./dist/maptiler-sdk.css"
  },
  "./style.css": {
    import: "./dist/maptiler-sdk.css"
  }
}, Ct = [
  "maptiler",
  "map",
  "sdk",
  "webmap",
  "cloud",
  "webGL",
  "maplibre"
], wt = "https://docs.maptiler.com/sdk-js/", St = "BSD-3-Clause", bt = {
  type: "git",
  url: "https://github.com/maptiler/maptiler-sdk-js.git"
}, Tt = {
  biome: "biome check --max-diagnostics=1000",
  "biome:fix": "npx @biomejs/biome check --max-diagnostics=1000 --write",
  doc: "rm -rf docs/* && typedoc --out docs && cp -r images docs/",
  test: "vitest run",
  "build-css": "node scripts/replace-path-with-content.js src/style/style_template.css dist/tmp_maptiler-sdk.css && cat node_modules/maplibre-gl/dist/maplibre-gl.css dist/tmp_maptiler-sdk.css > dist/maptiler-sdk.css && rm dist/tmp_maptiler-sdk.css && cp dist/maptiler-sdk.css build/maptiler-sdk.css",
  "build-umd": "NODE_ENV=production tsc && vite build -c vite.config-umd.ts",
  "build-es": "NODE_ENV=production tsc && vite build -c vite.config-es.ts",
  build: "npm run build-es; npm run build-umd; npm run build-css",
  make: "npm run biome:fix && npm run build"
}, Et = "MapTiler", It = {
  "@biomejs/biome": "1.8.3",
  "@types/uuid": "^9.0.2",
  "@types/xmldom": "^0.1.31",
  serve: "^14.2.0",
  terser: "^5.17.1",
  typedoc: "^0.24.8",
  typescript: "^5.1.6",
  vitest: "^0.34.2",
  vite: "^5.3.4",
  "vite-plugin-dts": "^4.0.0-beta.0"
}, Rt = {
  "@maptiler/client": "^1.8.1",
  events: "^3.3.0",
  "js-base64": "^3.7.4",
  "maplibre-gl": "4.4.1",
  uuid: "^9.0.0",
  xmldom: "^0.6.0"
}, _t = {
  name: ht,
  version: mt,
  description: ft,
  module: gt,
  types: yt,
  style: vt,
  type: Lt,
  exports: At,
  keywords: Ct,
  homepage: wt,
  license: St,
  repository: bt,
  scripts: Tt,
  author: Et,
  devDependencies: It,
  dependencies: Rt
}, C = {
  /**
   * The visitor language mode concatenates the prefered language from the user settings and the "default name".
   * Note: The "default name" is equivalent to OSM's `{name}`, which can be the most recognized names a global
   * scale or the local name.
   * This mode is helpful in the context where a user needs to access both the local names and the names in their
   * own language, for instance when traveling abroad, where signs likely to be only available in the local language.
   */
  VISITOR: "visitor",
  /**
   * The visitor language mode concatenates English and the "default name".
   * Note: The "default name" is equivalent to OSM's `{name}`, which can be the most recognized names a global
   * scale or the local name.
   * This mode is helpful in the context where a user needs to access both the local names and the names in their
   * own language, for instance when traveling abroad, where signs likely to be only available in the local language.
   */
  VISITOR_ENGLISH: "visitor_en",
  /**
   * Language as the style is designed. Not that this is the default state and one
   * the language has been changed to another than `STYLE`, then it cannot be set back to `STYLE`.
   */
  STYLE: "style",
  /**
   * AUTO mode uses the language of the browser
   */
  AUTO: "auto",
  /**
   * STYLE is a custom flag to keep the language of the map as defined into the style.
   * If STYLE is set in the constructor, then further modification of the language
   * with `.setLanguage()` is not possible.
   */
  STYLE_LOCK: "style_lock",
  /**
   * Default fallback languages that uses latin charaters
   */
  LATIN: "name:latin",
  /**
   * Default fallback languages that uses non-latin charaters
   */
  NON_LATIN: "name:nonlatin",
  /**
   * Labels are in their local language, when available
   */
  LOCAL: "name",
  /**
   * International name
   */
  INTERNATIONAL: "name_int",
  ALBANIAN: "name:sq",
  AMHARIC: "name:am",
  ARABIC: "name:ar",
  ARMENIAN: "name:hy",
  AZERBAIJANI: "name:az",
  BASQUE: "name:eu",
  BELORUSSIAN: "name:be",
  BENGALI: "name:bn",
  BOSNIAN: "name:bs",
  BRETON: "name:br",
  BULGARIAN: "name:bg",
  CATALAN: "name:ca",
  CHINESE: "name:zh",
  TRADITIONAL_CHINESE: "name:zh-Hant",
  SIMPLIFIED_CHINESE: "name:zh-Hans",
  CORSICAN: "name:co",
  CROATIAN: "name:hr",
  CZECH: "name:cs",
  DANISH: "name:da",
  DUTCH: "name:nl",
  ENGLISH: "name:en",
  ESPERANTO: "name:eo",
  ESTONIAN: "name:et",
  FINNISH: "name:fi",
  FRENCH: "name:fr",
  FRISIAN: "name:fy",
  GEORGIAN: "name:ka",
  GERMAN: "name:de",
  GREEK: "name:el",
  HEBREW: "name:he",
  HINDI: "name:hi",
  HUNGARIAN: "name:hu",
  ICELANDIC: "name:is",
  INDONESIAN: "name:id",
  IRISH: "name:ga",
  ITALIAN: "name:it",
  JAPANESE: "name:ja",
  JAPANESE_HIRAGANA: "name:ja-Hira",
  JAPANESE_KANA: "name:ja_kana",
  JAPANESE_LATIN: "name:ja_rm",
  JAPANESE_2018: "name:ja-Latn",
  KANNADA: "name:kn",
  KAZAKH: "name:kk",
  KOREAN: "name:ko",
  KOREAN_LATIN: "name:ko-Latn",
  KURDISH: "name:ku",
  ROMAN_LATIN: "name:la",
  LATVIAN: "name:lv",
  LITHUANIAN: "name:lt",
  LUXEMBOURGISH: "name:lb",
  MACEDONIAN: "name:mk",
  MALAYALAM: "name:ml",
  MALTESE: "name:mt",
  NORWEGIAN: "name:no",
  OCCITAN: "name:oc",
  PERSIAN: "name:fa",
  POLISH: "name:pl",
  PORTUGUESE: "name:pt",
  PUNJABI: "name:pa",
  WESTERN_PUNJABI: "name:pnb",
  ROMANIAN: "name:ro",
  ROMANSH: "name:rm",
  RUSSIAN: "name:ru",
  SCOTTISH_GAELIC: "name:gd",
  SERBIAN_CYRILLIC: "name:sr",
  SERBIAN_LATIN: "name:sr-Latn",
  SLOVAK: "name:sk",
  SLOVENE: "name:sl",
  SPANISH: "name:es",
  SWEDISH: "name:sv",
  TAMIL: "name:ta",
  TELUGU: "name:te",
  THAI: "name:th",
  TURKISH: "name:tr",
  UKRAINIAN: "name:uk",
  URDU: "name:ur",
  VIETNAMIAN_LATIN: "name:vi",
  WELSH: "name:cy"
}, xt = new Set(Object.values(C));
function ge(r) {
  return xt.has(r);
}
const Nt = new Set(Object.values(C));
function ye() {
  if (typeof navigator > "u")
    return `name:${Intl.DateTimeFormat().resolvedOptions().locale.split("-")[0]}`;
  const r = Array.from(new Set(navigator.languages.map((e) => `name:${e.split("-")[0]}`))).filter(
    (e) => Nt.has(e)
  );
  return r.length ? r[0] : C.LOCAL;
}
const k = {
  maptilerLogoURL: "https://api.maptiler.com/resources/logo.svg",
  maptilerURL: "https://www.maptiler.com/",
  maptilerApiHost: "api.maptiler.com",
  rtlPluginURL: "https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js",
  primaryLanguage: C.STYLE,
  secondaryLanguage: C.LOCAL,
  terrainSourceURL: "https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json",
  terrainSourceId: "maptiler-terrain"
};
Object.freeze(k);
const Fe = pt();
class Mt extends nt {
  constructor() {
    super(...arguments);
    /**
     * The primary language. By default, the language of the web browser is used.
     */
    T(this, "primaryLanguage", k.primaryLanguage);
    /**
     * The secondary language, to overwrite the default language defined in the map style.
     * This settings is highly dependant on the style compatibility and may not work in most cases.
     */
    T(this, "secondaryLanguage");
    /**
     * Setting on whether of not the SDK runs with a session logic.
     * A "session" is started at the initialization of the SDK and finished when the browser
     * page is being refreshed.
     * When `session` is enabled (default: true), the extra URL param `mtsid` is added to queries
     * on the MapTiler Cloud API. This allows MapTiler to enable "session based billing".
     */
    T(this, "session", !0);
    /**
     * Enables client-side caching of requests for tiles and fonts.
     * The cached requests persist multiple browser sessions and will be reused when possible.
     * Works only for requests to the MapTiler Cloud API when sessions are enabled.
     */
    T(this, "caching", !0);
    /**
     * Unit to be used
     */
    T(this, "_unit", "metric");
    /**
     * MapTiler Cloud API key
     */
    T(this, "_apiKey", "");
  }
  /**
   * Set the unit system
   */
  set unit(t) {
    this._unit = t, this.emit("unit", t);
  }
  /**
   * Get the unit system
   */
  get unit() {
    return this._unit;
  }
  /**
   * Set the MapTiler Cloud API key
   */
  set apiKey(t) {
    this._apiKey = t, ae.apiKey = t, this.emit("apiKey", t);
  }
  /**
   * Get the MapTiler Cloud API key
   */
  get apiKey() {
    return this._apiKey;
  }
  /**
   * Set a the custom fetch function to replace the default one
   */
  set fetch(t) {
    ae.fetch = t;
  }
  /**
   * Get the fetch fucntion
   */
  get fetch() {
    return ae.fetch;
  }
}
const N = new Mt(), { addProtocol: ve } = f, ie = "localcache_source", se = "localcache", Pt = "maptiler_sdk", Ot = 1e3, kt = 100, ce = typeof caches < "u";
function Ft(r, e) {
  if (ce && N.caching && N.session && r.host === k.maptilerApiHost) {
    if (e === "Source" && r.href.includes("tiles.json"))
      return r.href.replace("https://", `${ie}://`);
    if (e === "Tile" || e === "Glyphs")
      return r.href.replace("https://", `${se}://`);
  }
  return r.href;
}
let ne;
async function Be() {
  return ne || (ne = await caches.open(Pt)), ne;
}
let Le = 0;
async function Bt() {
  const r = await Be(), e = await r.keys(), t = e.slice(0, Math.max(e.length - Ot, 0));
  for (const o of t)
    r.delete(o);
}
function zt() {
  ve(
    ie,
    async (r, e) => {
      if (!r.url) throw new Error("");
      r.url = r.url.replace(`${ie}://`, "https://");
      const t = r;
      t.signal = e.signal;
      const o = await fetch(r.url, t), a = await o.json();
      return a.tiles && a.tiles.length > 0 && (a.tiles[0] += `&last-modified=${o.headers.get("Last-Modified")}`), {
        data: a,
        cacheControl: o.headers.get("Cache-Control"),
        expires: o.headers.get("Expires")
      };
    }
  ), ve(
    se,
    async (r, e) => {
      if (!r.url) throw new Error("");
      r.url = r.url.replace(`${se}://`, "https://");
      const t = new URL(r.url), o = new URL(t);
      o.searchParams.delete("mtsid"), o.searchParams.delete("key");
      const a = o.toString(), n = new URL(t);
      n.searchParams.delete("last-modified");
      const l = n.toString(), i = async (u) => ({
        data: await u.arrayBuffer(),
        cacheControl: u.headers.get("Cache-Control"),
        expires: u.headers.get("Expires")
      }), c = await Be(), h = await c.match(a);
      if (h)
        return i(h);
      const s = r;
      s.signal = e.signal;
      const p = await fetch(l, s);
      return p.status >= 200 && p.status < 300 && (c.put(a, p.clone()).catch(() => {
      }), ++Le > kt && (Bt(), Le = 0)), i(p);
    }
  );
}
function Ut() {
  if (typeof window > "u") return;
  const r = f.getRTLTextPluginStatus();
  if (r === "unavailable" || r === "requested")
    try {
      f.setRTLTextPlugin(k.rtlPluginURL, !0);
    } catch {
    }
}
function Dt(r, e) {
  for (const t of r)
    typeof e[t] == "function" && (e[t] = e[t].bind(e));
}
function V(r, e, t) {
  const o = window.document.createElement(r);
  return e !== void 0 && (o.className = e), t && t.appendChild(o), o;
}
function ze(r) {
  r.parentNode && r.parentNode.removeChild(r);
}
function Ae(r, e) {
  let t = null;
  try {
    t = new URL(r);
  } catch {
    return {
      url: r
    };
  }
  return t.host === k.maptilerApiHost && (t.searchParams.has("key") || t.searchParams.append("key", N.apiKey), N.session && t.searchParams.append("mtsid", Fe)), {
    url: Ft(t, e)
  };
}
function Ce(r) {
  return (e, t) => {
    if (r != null) {
      const o = r(e, t), a = Ae((o == null ? void 0 : o.url) ?? "", t);
      return {
        ...o,
        ...a
      };
    }
    return Ae(e, t);
  };
}
function Ue() {
  return Math.random().toString(36).substring(2);
}
function ee(r) {
  return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi.test(r);
}
function Ht(r) {
  try {
    return JSON.parse(r);
  } catch {
  }
  return null;
}
function Gt() {
  return document.createElement("canvas").getContext("webgl2") ? null : typeof WebGL2RenderingContext < "u" ? "Graphic rendering with WebGL2 has been disabled or is not supported by your graphic card. The map cannot be displayed." : "Your browser does not support graphic rendering with WebGL2. The map cannot be displayed.";
}
function Vt(r) {
  const e = Gt();
  if (!e) return;
  let t = null;
  if (typeof r == "string" ? t = document.getElementById(r) : r instanceof HTMLElement && (t = r), !t)
    throw new Error("The Map container must be provided.");
  const o = document.createElement("div");
  throw o.innerHTML = e, o.classList.add("no-webgl-support-div"), t.appendChild(o), new Error(e);
}
let Eo = class extends f.Marker {
  addTo(e) {
    return super.addTo(e);
  }
};
class Ro extends f.Popup {
  addTo(e) {
    return super.addTo(e);
  }
}
class _o extends f.Style {
  constructor(e, t = {}) {
    super(e, t);
  }
}
class xo extends f.CanvasSource {
  onAdd(e) {
    super.onAdd(e);
  }
}
class No extends f.GeoJSONSource {
  onAdd(e) {
    super.onAdd(e);
  }
}
class Mo extends f.ImageSource {
  onAdd(e) {
    super.onAdd(e);
  }
}
class Po extends f.RasterTileSource {
  onAdd(e) {
    super.onAdd(e);
  }
}
class Oo extends f.RasterDEMTileSource {
  onAdd(e) {
    super.onAdd(e);
  }
}
class ko extends f.VectorTileSource {
  onAdd(e) {
    super.onAdd(e);
  }
}
class Fo extends f.VideoSource {
  onAdd(e) {
    super.onAdd(e);
  }
}
class jt extends f.NavigationControl {
  onAdd(e) {
    return super.onAdd(e);
  }
}
class $t extends f.GeolocateControl {
  onAdd(e) {
    return super.onAdd(e);
  }
}
class Bo extends f.AttributionControl {
  onAdd(e) {
    return super.onAdd(e);
  }
}
class Kt extends f.LogoControl {
  onAdd(e) {
    return super.onAdd(e);
  }
}
class Zt extends f.ScaleControl {
  onAdd(e) {
    return super.onAdd(e);
  }
}
class Wt extends f.FullscreenControl {
  onAdd(e) {
    return super.onAdd(e);
  }
}
class zo extends f.TerrainControl {
  onAdd(e) {
    return super.onAdd(e);
  }
}
class Uo extends f.BoxZoomHandler {
  constructor(e, t) {
    super(e, t);
  }
}
class Do extends f.ScrollZoomHandler {
  constructor(e, t) {
    super(e, t);
  }
}
class Ho extends f.CooperativeGesturesHandler {
  constructor(e, t) {
    super(e, t);
  }
}
class Go extends f.KeyboardHandler {
  constructor(e) {
    super(e);
  }
}
class Vo extends f.TwoFingersTouchPitchHandler {
  constructor(e) {
    super(e);
  }
}
class jo extends f.MapWheelEvent {
  constructor(e, t, o) {
    super(e, t, o);
  }
}
class $o extends f.MapTouchEvent {
  constructor(e, t, o) {
    super(e, t, o);
  }
}
class Ko extends f.MapMouseEvent {
  constructor(e, t, o, a = {}) {
    super(e, t, o, a);
  }
}
class we extends Kt {
  constructor(t = {}) {
    super(t);
    T(this, "logoURL", "");
    T(this, "linkURL", "");
    this.logoURL = t.logoURL ?? k.maptilerLogoURL, this.linkURL = t.linkURL ?? k.maptilerURL;
  }
  onAdd(t) {
    this._map = t, this._compact = this.options.compact ?? !1, this._container = window.document.createElement("div"), this._container.className = "maplibregl-ctrl";
    const o = window.document.createElement("a");
    return o.style.backgroundRepeat = "no-repeat", o.style.cursor = "pointer", o.style.display = "block", o.style.height = "23px", o.style.margin = "0 0 -4px -4px", o.style.overflow = "hidden", o.style.width = "88px", o.style.backgroundImage = `url(${this.logoURL})`, o.style.backgroundSize = "100px 30px", o.style.width = "100px", o.style.height = "30px", o.target = "_blank", o.rel = "noopener", o.href = this.linkURL, o.setAttribute("aria-label", "MapTiler logo"), o.setAttribute("rel", "noopener"), this._container.appendChild(o), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
  }
}
function Se(r) {
  return r ? typeof r == "string" || r instanceof String ? !r.startsWith("http") && r.toLowerCase().includes(".json") ? r : st(r) : r instanceof ct ? r.getExpandedStyleURL() : r instanceof ut ? r.getDefaultVariant().getExpandedStyleURL() : r : lt[it[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL();
}
class Yt {
  constructor() {
    T(this, "_map");
    T(this, "_container");
    T(this, "_terrainButton");
    Dt(["_toggleTerrain", "_updateTerrainIcon"], this);
  }
  onAdd(e) {
    return this._map = e, this._container = V("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = V("button", "maplibregl-ctrl-terrain", this._container), V("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
  }
  onRemove() {
    ze(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
  }
  _toggleTerrain() {
    this._map.hasTerrain() ? this._map.disableTerrain() : this._map.enableTerrain(), this._updateTerrainIcon();
  }
  _updateTerrainIcon() {
    this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.hasTerrain() ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
  }
}
class Jt extends jt {
  constructor() {
    super({
      showCompass: !0,
      showZoom: !0,
      visualizePitch: !0
    });
    /**
     * Overloading: Limit how flat the compass icon can get
     */
    T(this, "_rotateCompassArrow", () => {
      const t = this.options.visualizePitch ? `scale(${Math.min(
        1.5,
        1 / Math.cos(this._map.transform.pitch * (Math.PI / 180)) ** 0.5
      )}) rotateX(${Math.min(70, this._map.transform.pitch)}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
      this._compassIcon.style.transform = t;
    });
    this._compass.removeEventListener("click", this._compass.clickFunction), this._compass.addEventListener("click", (t) => {
      this._map.getPitch() === 0 ? this._map.easeTo({ pitch: Math.min(this._map.getMaxPitch(), 80) }) : this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t }) : this._map.resetNorth({}, { originalEvent: t });
    });
  }
  /**
   * Overloading: the button now stores its click callback so that we can later on delete it and replace it
   */
  _createButton(t, o) {
    const a = super._createButton(t, o);
    return a.clickFunction = o, a;
  }
}
const be = f.Marker, Te = f.LngLat, qt = f.LngLatBounds;
class Xt extends $t {
  constructor() {
    super(...arguments);
    T(this, "lastUpdatedCenter", new Te(0, 0));
    /**
     * Update the camera location to center on the current position
     *
     * @param {Position} position the Geolocation API Position
     * @private
     */
    T(this, "_updateCamera", (t) => {
      var s, p;
      const o = new Te(t.coords.longitude, t.coords.latitude), a = t.coords.accuracy, l = {
        bearing: this._map.getBearing(),
        ...this.options.fitBoundsOptions,
        linear: !0
      }, i = this._map.getZoom();
      i > (((p = (s = this.options) == null ? void 0 : s.fitBoundsOptions) == null ? void 0 : p.maxZoom) ?? 30) && (l.zoom = i), this._map.fitBounds(qt.fromLngLat(o, a), l, {
        geolocateSource: !0
        // tag this camera change so it won't cause the control to change to background state
      });
      let c = !1;
      const h = () => {
        c = !0;
      };
      this._map.once("click", h), this._map.once("dblclick", h), this._map.once("dragstart", h), this._map.once("mousedown", h), this._map.once("touchstart", h), this._map.once("wheel", h), this._map.once("moveend", () => {
        this._map.off("click", h), this._map.off("dblclick", h), this._map.off("dragstart", h), this._map.off("mousedown", h), this._map.off("touchstart", h), this._map.off("wheel", h), !c && (this.lastUpdatedCenter = this._map.getCenter());
      });
    });
    T(this, "_setupUI", (t) => {
      if (this.lastUpdatedCenter = this._map.getCenter(), this._container.addEventListener("contextmenu", (o) => o.preventDefault()), this._geolocateButton = V("button", "maplibregl-ctrl-geolocate", this._container), V("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", t === !1) {
        const o = this._map._getUIString("GeolocateControl.LocationNotAvailable");
        this._geolocateButton.disabled = !0, this._geolocateButton.title = o, this._geolocateButton.setAttribute("aria-label", o);
      } else {
        const o = this._map._getUIString("GeolocateControl.FindMyLocation");
        this._geolocateButton.title = o, this._geolocateButton.setAttribute("aria-label", o);
      }
      this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = V("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new be({ element: this._dotElement }), this._circleElement = V("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new be({
        element: this._circleElement,
        pitchAlignment: "map"
      }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("move", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("moveend", (o) => {
        const a = o.originalEvent && o.originalEvent.type === "resize", n = this.lastUpdatedCenter.distanceTo(this._map.getCenter());
        !o.geolocateSource && this._watchState === "ACTIVE_LOCK" && !a && n > 1 && (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new Event("trackuserlocationend")));
      });
    });
    T(this, "_onZoom", () => {
      this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
    });
  }
  _updateCircleRadius() {
    if (this._watchState !== "BACKGROUND" && this._watchState !== "ACTIVE_LOCK")
      return;
    const t = [
      this._lastKnownPosition.coords.longitude,
      this._lastKnownPosition.coords.latitude
    ], o = this._map.project(t), a = this._map.unproject([o.x, o.y]), n = this._map.unproject([o.x + 20, o.y]), l = a.distanceTo(n) / 20, i = Math.ceil(2 * this._accuracy / l);
    this._circleElement.style.width = `${i}px`, this._circleElement.style.height = `${i}px`;
  }
}
var O, z, H, G, F, Y, _, De, B, He;
class le {
  constructor(e, t) {
    D(this, _);
    D(this, O);
    T(this, "map");
    D(this, z);
    D(this, H);
    D(this, G);
    D(this, F, !1);
    D(this, Y);
    e.style !== void 0 && $(this, F, !0), $(this, O, {
      // set defaults
      zoomAdjust: -4,
      position: "top-right",
      // inherit map options
      ...t,
      // override any lingering control options
      forceNoAttributionControl: !0,
      attributionControl: !1,
      navigationControl: !1,
      geolocateControl: !1,
      maptilerLogo: !1,
      minimap: !1,
      hash: !1,
      pitchAdjust: !1,
      // override map options with new user defined minimap options
      ...e,
      containerStyle: {
        border: "1px solid #000",
        width: "400px",
        height: "300px",
        ...e.containerStyle ?? {}
      }
    }), e.lockZoom !== void 0 && (L(this, O).minZoom = e.lockZoom, L(this, O).maxZoom = e.lockZoom);
  }
  setStyle(e, t) {
    L(this, F) || this.map.setStyle(e, t), P(this, _, B).call(this);
  }
  addLayer(e, t) {
    return L(this, F) || this.map.addLayer(e, t), P(this, _, B).call(this), this.map;
  }
  moveLayer(e, t) {
    return L(this, F) || this.map.moveLayer(e, t), P(this, _, B).call(this), this.map;
  }
  removeLayer(e) {
    return L(this, F) || this.map.removeLayer(e), P(this, _, B).call(this), this;
  }
  setLayerZoomRange(e, t, o) {
    return L(this, F) || this.map.setLayerZoomRange(e, t, o), P(this, _, B).call(this), this;
  }
  setFilter(e, t, o) {
    return L(this, F) || this.map.setFilter(e, t, o), P(this, _, B).call(this), this;
  }
  setPaintProperty(e, t, o, a) {
    return L(this, F) || this.map.setPaintProperty(e, t, o, a), P(this, _, B).call(this), this;
  }
  setLayoutProperty(e, t, o, a) {
    return L(this, F) || this.map.setLayoutProperty(e, t, o, a), P(this, _, B).call(this), this;
  }
  setGlyphs(e, t) {
    return L(this, F) || this.map.setGlyphs(e, t), P(this, _, B).call(this), this;
  }
  onAdd(e) {
    $(this, z, e), $(this, H, V("div", "maplibregl-ctrl maplibregl-ctrl-group"));
    for (const [t, o] of Object.entries(L(this, O).containerStyle))
      L(this, H).style.setProperty(t, o);
    return L(this, O).container = L(this, H), L(this, O).zoom = e.getZoom() + L(this, O).zoomAdjust, this.map = new eo(L(this, O)), this.map.once("style.load", () => {
      this.map.resize();
    }), this.map.once("load", () => {
      P(this, _, De).call(this, L(this, O).parentRect), $(this, Y, P(this, _, He).call(this));
    }), L(this, H);
  }
  onRemove() {
    var e;
    (e = L(this, Y)) == null || e.call(this), ze(L(this, H));
  }
}
O = new WeakMap(), z = new WeakMap(), H = new WeakMap(), G = new WeakMap(), F = new WeakMap(), Y = new WeakMap(), _ = new WeakSet(), De = function(e) {
  e === void 0 || e.linePaint === void 0 && e.fillPaint === void 0 || ($(this, G, {
    type: "Feature",
    properties: {
      name: "parentRect"
    },
    geometry: {
      type: "Polygon",
      coordinates: [[[], [], [], [], []]]
    }
  }), this.map.addSource("parentRect", {
    type: "geojson",
    data: L(this, G)
  }), (e.lineLayout !== void 0 || e.linePaint !== void 0) && this.map.addLayer({
    id: "parentRectOutline",
    type: "line",
    source: "parentRect",
    layout: {
      ...e.lineLayout
    },
    paint: {
      "line-color": "#FFF",
      "line-width": 1,
      "line-opacity": 0.85,
      ...e.linePaint
    }
  }), e.fillPaint !== void 0 && this.map.addLayer({
    id: "parentRectFill",
    type: "fill",
    source: "parentRect",
    layout: {},
    paint: {
      "fill-color": "#08F",
      "fill-opacity": 0.135,
      ...e.fillPaint
    }
  }), P(this, _, B).call(this));
}, B = function() {
  if (L(this, G) === void 0) return;
  const { devicePixelRatio: e } = window, t = L(this, z).getCanvas(), o = t.width / e, a = t.height / e, n = L(this, z).unproject.bind(L(this, z)), l = n([0, 0]), i = n([o, 0]), c = n([0, a]), h = n([o, a]);
  L(this, G).geometry.coordinates = [
    [c.toArray(), h.toArray(), i.toArray(), l.toArray(), c.toArray()]
  ], this.map.getSource("parentRect").setData(L(this, G));
}, He = function() {
  const { pitchAdjust: e } = L(this, O), t = () => {
    l("parent");
  }, o = () => {
    l("minimap");
  }, a = () => {
    L(this, z).on("move", t), this.map.on("move", o);
  }, n = () => {
    L(this, z).off("move", t), this.map.off("move", o);
  }, l = (i) => {
    n();
    const c = i === "parent" ? L(this, z) : this.map, h = i === "parent" ? this.map : L(this, z), s = c.getCenter(), p = c.getZoom() + (L(this, O).zoomAdjust ?? -4) * (i === "parent" ? 1 : -1), u = c.getBearing(), d = c.getPitch();
    h.jumpTo({
      center: s,
      zoom: p,
      bearing: u,
      pitch: e ? d : 0
    }), P(this, _, B).call(this), a();
  };
  return a(), () => {
    n();
  };
};
const Qt = {
  POINT: "POINT",
  COUNTRY: "COUNTRY"
};
class eo extends f.Map {
  constructor(t) {
    Vt(t.container), t.apiKey && (N.apiKey = t.apiKey);
    const o = Se(t.style), a = location.hash;
    N.apiKey || console.warn("MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!");
    let n = {
      compact: !1
    };
    t.customAttribution ? n.customAttribution = t.customAttribution : t.attributionControl && typeof t.attributionControl == "object" && (n = {
      ...n,
      ...t.attributionControl
    });
    super({
      ...t,
      style: o,
      maplibreLogo: !1,
      transformRequest: Ce(t.transformRequest),
      attributionControl: t.forceNoAttributionControl === !0 ? !1 : n
    });
    T(this, "isTerrainEnabled", !1);
    T(this, "terrainExaggeration", 1);
    T(this, "primaryLanguage");
    T(this, "terrainGrowing", !1);
    T(this, "terrainFlattening", !1);
    T(this, "minimap");
    T(this, "forceLanguageUpdate");
    T(this, "languageAlwaysBeenStyle");
    T(this, "isReady", !1);
    N.caching && !ce && console.warn(
      "The cache API is only available in secure contexts. More info at https://developer.mozilla.org/en-US/docs/Web/API/Cache"
    ), N.caching && ce && zt(), this.primaryLanguage = t.language ?? N.primaryLanguage, this.forceLanguageUpdate = !(this.primaryLanguage === C.STYLE || this.primaryLanguage === C.STYLE_LOCK), this.languageAlwaysBeenStyle = this.primaryLanguage === C.STYLE, this.terrainExaggeration = t.terrainExaggeration ?? this.terrainExaggeration, this.once("styledata", async () => {
      if (!t.geolocate || t.center || t.hash && a)
        return;
      try {
        if (t.geolocate === Qt.COUNTRY) {
          await this.fitToIpBounds();
          return;
        }
      } catch (u) {
        console.warn(u.message);
      }
      let s;
      try {
        await this.centerOnIpPoint(t.zoom), s = this.getCameraHash();
      } catch (u) {
        console.warn(u.message);
      }
      (await navigator.permissions.query({
        name: "geolocation"
      })).state === "granted" && navigator.geolocation.getCurrentPosition(
        // success callback
        (u) => {
          s === this.getCameraHash() && (this.terrain ? this.easeTo({
            center: [u.coords.longitude, u.coords.latitude],
            zoom: t.zoom || 12,
            duration: 2e3
          }) : this.once("terrain", () => {
            this.easeTo({
              center: [u.coords.longitude, u.coords.latitude],
              zoom: t.zoom || 12,
              duration: 2e3
            });
          }));
        },
        // error callback
        null,
        // options
        {
          maximumAge: 24 * 3600 * 1e3,
          // a day in millisec
          timeout: 5e3,
          // milliseconds
          enableHighAccuracy: !1
        }
      );
    }), this.on("styledata", () => {
      this.setPrimaryLanguage(this.primaryLanguage);
    }), this.on("styledata", () => {
      this.getTerrain() === null && this.isTerrainEnabled && this.enableTerrain(this.terrainExaggeration);
    }), this.once("load", async () => {
      let s = { logo: null };
      try {
        const p = Object.keys(this.style.sourceCaches).map((m) => this.getSource(m)).filter(
          (m) => m && "url" in m && typeof m.url == "string" && (m == null ? void 0 : m.url.includes("tiles.json"))
        ), u = new URL(p[0].url);
        u.searchParams.has("key") || u.searchParams.append("key", N.apiKey), s = await (await fetch(u.href)).json();
      } catch {
      }
      if (t.forceNoAttributionControl !== !0)
        if ("logo" in s && s.logo) {
          const p = s.logo;
          this.addControl(new we({ logoURL: p }), t.logoPosition);
        } else t.maptilerLogo && this.addControl(new we(), t.logoPosition);
      if (t.scaleControl) {
        const p = t.scaleControl === !0 || t.scaleControl === void 0 ? "bottom-right" : t.scaleControl, u = new Zt({ unit: N.unit });
        this.addControl(u, p), N.on("unit", (d) => {
          u.setUnit(d);
        });
      }
      if (t.navigationControl !== !1) {
        const p = t.navigationControl === !0 || t.navigationControl === void 0 ? "top-right" : t.navigationControl;
        this.addControl(new Jt(), p);
      }
      if (t.geolocateControl !== !1) {
        const p = t.geolocateControl === !0 || t.geolocateControl === void 0 ? "top-right" : t.geolocateControl;
        this.addControl(
          // new maplibregl.GeolocateControl({
          new Xt({
            positionOptions: {
              enableHighAccuracy: !0,
              maximumAge: 0,
              timeout: 6e3
            },
            fitBoundsOptions: {
              maxZoom: 15
            },
            trackUserLocation: !0,
            showAccuracyCircle: !0,
            showUserLocation: !0
          }),
          p
        );
      }
      if (t.terrainControl) {
        const p = t.terrainControl === !0 || t.terrainControl === void 0 ? "top-right" : t.terrainControl;
        this.addControl(new Yt(), p);
      }
      if (t.fullscreenControl) {
        const p = t.fullscreenControl === !0 || t.fullscreenControl === void 0 ? "top-right" : t.fullscreenControl;
        this.addControl(new Wt({}), p);
      }
      this.isReady = !0, this.fire("ready", { target: this });
    });
    let l = !1, i = !1, c;
    this.once("ready", () => {
      l = !0, i && this.fire("loadWithTerrain", c);
    }), this.once("style.load", () => {
      const { minimap: s } = t;
      if (typeof s == "object") {
        const {
          zoom: p,
          center: u,
          style: d,
          language: m,
          apiKey: v,
          maptilerLogo: w,
          antialias: M,
          refreshExpiredTiles: A,
          maxBounds: I,
          scrollZoom: R,
          minZoom: E,
          maxZoom: U,
          boxZoom: j,
          locale: W,
          fadeDuration: J,
          crossSourceCollisions: q,
          clickTolerance: Xe,
          bounds: Qe,
          fitBoundsOptions: et,
          pixelRatio: tt,
          validateStyle: ot
        } = t;
        this.minimap = new le(s, {
          zoom: p,
          center: u,
          style: d,
          language: m,
          apiKey: v,
          container: "null",
          maptilerLogo: w,
          antialias: M,
          refreshExpiredTiles: A,
          maxBounds: I,
          scrollZoom: R,
          minZoom: E,
          maxZoom: U,
          boxZoom: j,
          locale: W,
          fadeDuration: J,
          crossSourceCollisions: q,
          clickTolerance: Xe,
          bounds: Qe,
          fitBoundsOptions: et,
          pixelRatio: tt,
          validateStyle: ot
        }), this.addControl(this.minimap, s.position ?? "bottom-left");
      } else s === !0 ? (this.minimap = new le({}, t), this.addControl(this.minimap, "bottom-left")) : s !== void 0 && s !== !1 && (this.minimap = new le({}, t), this.addControl(this.minimap, s));
    });
    const h = (s) => {
      s.terrain && (i = !0, c = {
        type: "loadWithTerrain",
        target: this,
        terrain: s.terrain
      }, this.off("terrain", h), l && this.fire("loadWithTerrain", c));
    };
    this.on("terrain", h), t.terrain && this.enableTerrain(t.terrainExaggeration ?? this.terrainExaggeration);
  }
  /**
   * Awaits for _this_ Map instance to be "loaded" and returns a Promise to the Map.
   * If _this_ Map instance is already loaded, the Promise is resolved directly,
   * otherwise, it is resolved as a result of the "load" event.
   * @returns
   */
  async onLoadAsync() {
    return new Promise((t) => {
      if (this.loaded())
        return t(this);
      this.once("load", () => {
        t(this);
      });
    });
  }
  /**
   * Awaits for _this_ Map instance to be "ready" and returns a Promise to the Map.
   * If _this_ Map instance is already ready, the Promise is resolved directly,
   * otherwise, it is resolved as a result of the "ready" event.
   * A map instance is "ready" when all the controls that can be managed by the contructor are
   * dealt with. This happens after the "load" event, due to the asynchronous nature
   * of some built-in controls.
   */
  async onReadyAsync() {
    return new Promise((t) => {
      if (this.isReady)
        return t(this);
      this.once("ready", () => {
        t(this);
      });
    });
  }
  /**
   * Awaits for _this_ Map instance to be "loaded" as well as with terrain being non-null for the first time
   * and returns a Promise to the Map.
   * If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,
   * otherwise, it is resolved as a result of the "loadWithTerrain" event.
   * @returns
   */
  async onLoadWithTerrainAsync() {
    return new Promise((t) => {
      if (this.isReady && this.terrain)
        return t(this);
      this.once("loadWithTerrain", () => {
        t(this);
      });
    });
  }
  /**
   * Update the style of the map.
   * Can be:
   * - a full style URL (possibly with API key)
   * - a shorthand with only the MapTIler style name (eg. `"streets-v2"`)
   * - a longer form with the prefix `"maptiler://"` (eg. `"maptiler://streets-v2"`)
   */
  setStyle(t, o) {
    var a;
    return (a = this.minimap) == null || a.setStyle(t), this.forceLanguageUpdate = !0, this.once("idle", () => {
      this.forceLanguageUpdate = !1;
    }), super.setStyle(Se(t), o);
  }
  /**
   * Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)
   * to the map's style.
   *
   * A layer defines how data from a specified source will be styled. Read more about layer types
   * and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).
   *
   * @param layer - The layer to add,
   * conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,
   * less commonly, the {@link CustomLayerInterface} specification.
   * The MapLibre Style Specification's layer definition is appropriate for most layers.
   *
   * @param beforeId - The ID of an existing layer to insert the new layer before,
   * resulting in the new layer appearing visually beneath the existing layer.
   * If this argument is not specified, the layer will be appended to the end of the layers array
   * and appear visually above all other layers.
   *
   * @returns `this`
   */
  addLayer(t, o) {
    var a;
    return (a = this.minimap) == null || a.addLayer(t, o), super.addLayer(t, o);
  }
  /**
   * Moves a layer to a different z-position.
   *
   * @param id - The ID of the layer to move.
   * @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.
   * @returns `this`
   *
   * @example
   * Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.
   * ```ts
   * map.moveLayer('polygon', 'country-label');
   * ```
   */
  moveLayer(t, o) {
    var a;
    return (a = this.minimap) == null || a.moveLayer(t, o), super.moveLayer(t, o);
  }
  /**
   * Removes the layer with the given ID from the map's style.
   *
   * An {@link ErrorEvent} will be fired if the image parameter is invald.
   *
   * @param id - The ID of the layer to remove
   * @returns `this`
   *
   * @example
   * If a layer with ID 'state-data' exists, remove it.
   * ```ts
   * if (map.getLayer('state-data')) map.removeLayer('state-data');
   * ```
   */
  removeLayer(t) {
    var o;
    return (o = this.minimap) == null || o.removeLayer(t), super.removeLayer(t);
  }
  /**
   * Sets the zoom extent for the specified style layer. The zoom extent includes the
   * [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)
   * and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))
   * at which the layer will be rendered.
   *
   * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the
   * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum
   * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style
   * layer will not be rendered at all zoom levels in the zoom range.
   */
  setLayerZoomRange(t, o, a) {
    var n;
    return (n = this.minimap) == null || n.setLayerZoomRange(t, o, a), super.setLayerZoomRange(t, o, a);
  }
  /**
   * Sets the filter for the specified style layer.
   *
   * Filters control which features a style layer renders from its source.
   * Any feature for which the filter expression evaluates to `true` will be
   * rendered on the map. Those that are false will be hidden.
   *
   * Use `setFilter` to show a subset of your source data.
   *
   * To clear the filter, pass `null` or `undefined` as the second parameter.
   */
  setFilter(t, o, a) {
    var n;
    return (n = this.minimap) == null || n.setFilter(t, o, a), super.setFilter(t, o, a);
  }
  /**
   * Sets the value of a paint property in the specified style layer.
   *
   * @param layerId - The ID of the layer to set the paint property in.
   * @param name - The name of the paint property to set.
   * @param value - The value of the paint property to set.
   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
   * @param options - Options object.
   * @returns `this`
   * @example
   * ```ts
   * map.setPaintProperty('my-layer', 'fill-color', '#faafee');
   * ```
   */
  setPaintProperty(t, o, a, n) {
    var l;
    return (l = this.minimap) == null || l.setPaintProperty(t, o, a, n), super.setPaintProperty(t, o, a, n);
  }
  /**
   * Sets the value of a layout property in the specified style layer.
   * Layout properties define how the layer is styled.
   * Layout properties for layers of the same type are documented together.
   * Layers of different types have different layout properties.
   * See the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/) for the complete list of layout properties.
   * @param layerId - The ID of the layer to set the layout property in.
   * @param name - The name of the layout property to set.
   * @param value - The value of the layout property to set.
   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
   * @param options - Options object.
   * @returns `this`
   */
  setLayoutProperty(t, o, a, n) {
    var l;
    return (l = this.minimap) == null || l.setLayoutProperty(t, o, a, n), super.setLayoutProperty(t, o, a, n);
  }
  /**
   * Sets the value of the style's glyphs property.
   *
   * @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).
   * @param options - Options object.
   * @returns `this`
   * @example
   * ```ts
   * map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');
   * ```
   */
  setGlyphs(t, o) {
    var a;
    return (a = this.minimap) == null || a.setGlyphs(t, o), super.setGlyphs(t, o);
  }
  getStyleLanguage() {
    return !this.style.stylesheet.metadata || typeof this.style.stylesheet.metadata != "object" ? null : "maptiler:language" in this.style.stylesheet.metadata && typeof this.style.stylesheet.metadata["maptiler:language"] == "string" ? this.style.stylesheet.metadata["maptiler:language"] : null;
  }
  /**
   * Define the primary language of the map. Note that not all the languages shorthands provided are available.
   */
  setLanguage(t) {
    var o, a;
    (a = (o = this.minimap) == null ? void 0 : o.map) == null || a.setLanguage(t), this.onStyleReady(() => {
      this.setPrimaryLanguage(t);
    });
  }
  /**
   * Define the primary language of the map. Note that not all the languages shorthands provided are available.
   */
  setPrimaryLanguage(t) {
    const o = this.getStyleLanguage();
    if (!(t === C.STYLE && (o === C.AUTO || o === C.VISITOR)) && (t !== C.STYLE && (this.languageAlwaysBeenStyle = !1), this.languageAlwaysBeenStyle || this.primaryLanguage === t && !this.forceLanguageUpdate))
      return;
    if (!ge(t)) {
      console.warn(`The language "${t}" is not supported.`);
      return;
    }
    if (this.primaryLanguage === C.STYLE_LOCK) {
      console.warn(
        "The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag."
      );
      return;
    }
    this.primaryLanguage = t;
    let a = t;
    if (t === C.STYLE) {
      if (!o) {
        console.warn("The style has no default languages.");
        return;
      }
      if (!ge(o)) {
        console.warn("The language defined in the style is not valid.");
        return;
      }
      a = o;
    }
    let n = C.LOCAL, l = `{${n}}`;
    a === C.VISITOR ? (n = ye(), l = [
      "case",
      ["all", ["has", n], ["has", C.LOCAL]],
      [
        "case",
        ["==", ["get", n], ["get", C.LOCAL]],
        ["get", C.LOCAL],
        ["format", ["get", n], { "font-scale": 0.8 }, `
`, ["get", C.LOCAL], { "font-scale": 1.1 }]
      ],
      ["get", C.LOCAL]
    ]) : a === C.VISITOR_ENGLISH ? (n = C.ENGLISH, l = [
      "case",
      ["all", ["has", n], ["has", C.LOCAL]],
      [
        "case",
        ["==", ["get", n], ["get", C.LOCAL]],
        ["get", C.LOCAL],
        ["format", ["get", n], { "font-scale": 0.8 }, `
`, ["get", C.LOCAL], { "font-scale": 1.1 }]
      ],
      ["get", C.LOCAL]
    ]) : a === C.AUTO ? (n = ye(), l = ["case", ["has", n], ["get", n], ["get", C.LOCAL]]) : a === C.LOCAL ? (n = C.LOCAL, l = `{${n}}`) : (n = a, l = ["case", ["has", n], ["get", n], ["get", C.LOCAL]]);
    const { layers: i } = this.getStyle();
    for (const c of i) {
      if (c.type !== "symbol")
        continue;
      const h = c, s = this.getSource(h.source);
      if (!s || !("url" in s && typeof s.url == "string") || new URL(s.url).host !== k.maptilerApiHost)
        continue;
      const { id: u, layout: d } = h;
      if (!d || !("text-field" in d))
        continue;
      const m = this.getLayoutProperty(u, "text-field");
      typeof m == "string" && (m.toLowerCase().includes("ref") || m.toLowerCase().includes("housenumber")) || this.setLayoutProperty(u, "text-field", l);
    }
  }
  /**
   * Get the primary language
   * @returns
   */
  getPrimaryLanguage() {
    return this.primaryLanguage;
  }
  /**
   * Get the exaggeration factor applied to the terrain
   * @returns
   */
  getTerrainExaggeration() {
    return this.terrainExaggeration;
  }
  /**
   * Know if terrian is enabled or not
   * @returns
   */
  hasTerrain() {
    return this.isTerrainEnabled;
  }
  growTerrain(t, o = 1e3) {
    if (!this.terrain)
      return;
    const a = performance.now(), n = this.terrain.exaggeration, l = t - n, i = () => {
      if (!this.terrain || this.terrainFlattening)
        return;
      const c = (performance.now() - a) / o;
      if (c < 0.99) {
        const h = 1 - (1 - c) ** 4, s = n + h * l;
        this.terrain.exaggeration = s, requestAnimationFrame(i);
      } else
        this.terrainGrowing = !1, this.terrainFlattening = !1, this.terrain.exaggeration = t;
      this.triggerRepaint();
    };
    this.terrainGrowing = !0, this.terrainFlattening = !1, requestAnimationFrame(i);
  }
  /**
   * Enables the 3D terrain visualization
   */
  enableTerrain(t = this.terrainExaggeration) {
    if (t < 0) {
      console.warn("Terrain exaggeration cannot be negative.");
      return;
    }
    const o = async (n) => {
      !this.terrain || n.type !== "data" || n.dataType !== "source" || !("source" in n) || n.sourceId !== "maptiler-terrain" || n.source.type !== "raster-dem" || n.isSourceLoaded && (this.off("data", o), this.growTerrain(t));
    }, a = () => {
      this.isTerrainEnabled = !0, this.terrainExaggeration = t, this.on("data", o), this.addSource(k.terrainSourceId, {
        type: "raster-dem",
        url: k.terrainSourceURL
      }), this.setTerrain({
        source: k.terrainSourceId,
        exaggeration: 0
      });
    };
    if (this.getTerrain()) {
      this.isTerrainEnabled = !0, this.growTerrain(t);
      return;
    }
    this.loaded() || this.isTerrainEnabled ? a() : this.once("load", () => {
      this.getTerrain() && this.getSource(k.terrainSourceId) || a();
    });
  }
  /**
   * Disable the 3D terrain visualization
   */
  disableTerrain() {
    if (!this.terrain)
      return;
    this.isTerrainEnabled = !1;
    const t = 1 * 1e3, o = performance.now(), a = this.terrain.exaggeration, n = () => {
      if (!this.terrain || this.terrainGrowing)
        return;
      const l = (performance.now() - o) / t;
      if (l < 0.99) {
        const i = (1 - l) ** 4, c = a * i;
        this.terrain.exaggeration = c, requestAnimationFrame(n);
      } else
        this.terrain.exaggeration = 0, this.terrainGrowing = !1, this.terrainFlattening = !1, this.setTerrain(), this.getSource(k.terrainSourceId) && this.removeSource(k.terrainSourceId);
      this.triggerRepaint();
    };
    this.terrainGrowing = !1, this.terrainFlattening = !0, requestAnimationFrame(n);
  }
  /**
   * Sets the 3D terrain exageration factor.
   * If the terrain was not enabled prior to the call of this method,
   * the method `.enableTerrain()` will be called.
   * If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.
   * If `animate` is `false`, no animated transition to the newly defined exaggeration.
   */
  setTerrainExaggeration(t, o = !0) {
    !o && this.terrain ? (this.terrainExaggeration = t, this.terrain.exaggeration = t, this.triggerRepaint()) : this.enableTerrain(t);
  }
  /**
   * Perform an action when the style is ready. It could be at the moment of calling this method
   * or later.
   */
  onStyleReady(t) {
    this.isStyleLoaded() ? t() : this.once("styledata", () => {
      t();
    });
  }
  async fitToIpBounds() {
    const t = await fe.info();
    this.fitBounds(t.country_bounds, {
      duration: 0,
      padding: 100
    });
  }
  async centerOnIpPoint(t) {
    const o = await fe.info();
    this.jumpTo({
      center: [(o == null ? void 0 : o.longitude) ?? 0, (o == null ? void 0 : o.latitude) ?? 0],
      zoom: t || 11
    });
  }
  getCameraHash() {
    const t = new Float32Array(5), o = this.getCenter();
    return t[0] = o.lng, t[1] = o.lat, t[2] = this.getZoom(), t[3] = this.getPitch(), t[4] = this.getBearing(), dt.fromUint8Array(new Uint8Array(t.buffer));
  }
  /**
   * Get the SDK config object.
   * This is convenient to dispatch the SDK configuration to externally built layers
   * that do not directly have access to the SDK configuration but do have access to a Map instance.
   */
  getSdkConfig() {
    return N;
  }
  /**
   * Get the MapTiler session ID. Convenient to dispatch to externaly built component
   * that do not directly have access to the SDK configuration but do have access to a Map instance.
   * @returns
   */
  getMaptilerSessionId() {
    return Fe;
  }
  /**
   *  Updates the requestManager's transform request with a new function.
   *
   * @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.
   *    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties
   *
   * @returns {Map} `this`
   *
   *  @example
   *  map.setTransformRequest((url: string, resourceType: string) => {});
   */
  setTransformRequest(t) {
    return super.setTransformRequest(Ce(t)), this;
  }
}
function pe(r) {
  if (typeof DOMParser < "u") {
    const e = new DOMParser().parseFromString(r, "application/xml");
    if (e.querySelector("parsererror"))
      throw new Error("The provided string is not valid XML");
    return e;
  }
  throw new Error("No XML parser found");
}
function Ge(r, e) {
  if (!r.hasChildNodes())
    return !1;
  for (const t of Array.from(r.childNodes)) {
    const o = t.nodeName;
    if (typeof o == "string" && o.trim().toLowerCase() === e.toLowerCase())
      return !0;
  }
  return !1;
}
function Ee(r) {
  if (typeof XMLSerializer < "u")
    return new XMLSerializer().serializeToString(r);
  throw new Error("No XML serializer found");
}
function Ve(r) {
  const e = typeof r == "string" ? pe(r) : r;
  if (!Ge(e, "gpx"))
    throw new Error("The XML document is not valid GPX");
  const t = x(e, "trk"), o = x(e, "rte"), a = x(e, "wpt"), n = {
    type: "FeatureCollection",
    features: []
  };
  for (const l of Array.from(t)) {
    const i = ao(l);
    i && n.features.push(i);
  }
  for (const l of Array.from(o)) {
    const i = no(l);
    i && n.features.push(i);
  }
  for (const l of Array.from(a))
    n.features.push(lo(l));
  return n;
}
function je(r, e) {
  let t = r;
  if (typeof t == "string" && (t = pe(t)), !Ge(t, "kml"))
    throw new Error("The XML document is not valid KML");
  const o = {
    type: "FeatureCollection",
    features: []
  }, a = {}, n = {}, l = {}, i = x(t, "Placemark"), c = x(t, "Style"), h = x(t, "StyleMap");
  for (const s of Array.from(c)) {
    const p = Re(e !== void 0 ? e(s) : Ee(s)).toString(16);
    a[`#${K(s, "id")}`] = p, n[p] = s;
  }
  for (const s of Array.from(h)) {
    a[`#${K(s, "id")}`] = Re(
      e !== void 0 ? e(s) : Ee(s)
    ).toString(16);
    const p = x(s, "Pair"), u = {};
    for (const d of Array.from(p))
      u[S(y(d, "key")) ?? ""] = S(y(d, "styleUrl"));
    l[`#${K(s, "id")}`] = u;
  }
  for (const s of Array.from(i))
    o.features = o.features.concat(ro(s, a, n, l));
  return o;
}
function Ie(r) {
  if (r === null) return ["#000000", 1];
  let e = "", t = 1, o = r;
  return o.substring(0, 1) === "#" && (o = o.substring(1)), (o.length === 6 || o.length === 3) && (e = o), o.length === 8 && (t = Number.parseInt(o.substring(0, 2), 16) / 255, e = `#${o.substring(6, 8)}${o.substring(4, 6)}${o.substring(2, 4)}`), [e ?? "#000000", t ?? 1];
}
function to(r) {
  return Ze(r.split(" "));
}
function oo(r) {
  let e = x(r, "coord");
  const t = [], o = [];
  e.length === 0 && (e = x(r, "gx:coord"));
  for (const n of Array.from(e))
    t.push(to(S(n) ?? ""));
  const a = x(r, "when");
  for (const n of Array.from(a)) o.push(S(n));
  return {
    coords: t,
    times: o
  };
}
function Q(r) {
  const e = ["Polygon", "LineString", "Point", "Track", "gx:Track"];
  let t, o, a, n, l;
  const i = [], c = [];
  if (y(r, "MultiGeometry") !== null)
    return Q(y(r, "MultiGeometry"));
  if (y(r, "MultiTrack") !== null)
    return Q(y(r, "MultiTrack"));
  if (y(r, "gx:MultiTrack") !== null)
    return Q(y(r, "gx:MultiTrack"));
  for (a = 0; a < e.length; a++)
    if (o = x(r, e[a]), o) {
      for (n = 0; n < o.length; n++)
        if (t = o[n], e[a] === "Point")
          i.push({
            type: "Point",
            coordinates: We(S(y(t, "coordinates")) ?? "")
          });
        else if (e[a] === "LineString")
          i.push({
            type: "LineString",
            coordinates: xe(S(y(t, "coordinates")) ?? "")
          });
        else if (e[a] === "Polygon") {
          const h = x(t, "LinearRing"), s = [];
          for (l = 0; l < h.length; l++)
            s.push(xe(S(y(h[l], "coordinates")) ?? ""));
          i.push({
            type: "Polygon",
            coordinates: s
          });
        } else if (e[a] === "Track" || e[a] === "gx:Track") {
          const h = oo(t);
          i.push({
            type: "LineString",
            coordinates: h.coords
          }), h.times.length && c.push(h.times);
        }
    }
  return { geoms: i, coordTimes: c };
}
function ro(r, e, t, o) {
  const a = Q(r), n = {}, l = S(y(r, "name")), i = S(y(r, "address")), c = S(y(r, "description")), h = y(r, "TimeSpan"), s = y(r, "TimeStamp"), p = y(r, "ExtendedData"), u = y(r, "visibility");
  let d, m = S(y(r, "styleUrl")), v = y(r, "LineStyle"), w = y(r, "PolyStyle");
  if (!a.geoms.length) return [];
  if (l && (n.name = l), i && (n.address = i), m) {
    m[0] !== "#" && (m = `#${m}`), n.styleUrl = m, e[m] && (n.styleHash = e[m]), o[m] && (n.styleMapHash = o[m], n.styleHash = e[o[m].normal ?? ""]);
    const A = t[n.styleHash ?? ""];
    if (A) {
      v || (v = y(A, "LineStyle")), w || (w = y(A, "PolyStyle"));
      const I = y(A, "IconStyle");
      if (I) {
        const R = y(I, "Icon");
        if (R) {
          const E = S(y(R, "href"));
          E && (n.icon = E);
        }
      }
    }
  }
  if (c && (n.description = c), h) {
    const A = S(y(h, "begin")), I = S(y(h, "end"));
    A && I && (n.timespan = { begin: A, end: I });
  }
  if (s !== null && (n.timestamp = S(y(s, "when")) ?? (/* @__PURE__ */ new Date()).toISOString()), v !== null) {
    const A = Ie(S(y(v, "color"))), I = A[0], R = A[1], E = Number.parseFloat(S(y(v, "width")) ?? "");
    I && (n.stroke = I), Number.isNaN(R) || (n["stroke-opacity"] = R), Number.isNaN(E) || (n["stroke-width"] = E);
  }
  if (w) {
    const A = Ie(S(y(w, "color"))), I = A[0], R = A[1], E = S(y(w, "fill")), U = S(y(w, "outline"));
    I && (n.fill = I), Number.isNaN(R) || (n["fill-opacity"] = R), E && (n["fill-opacity"] = E === "1" ? n["fill-opacity"] || 1 : 0), U && (n["stroke-opacity"] = U === "1" ? n["stroke-opacity"] || 1 : 0);
  }
  if (p) {
    const A = x(p, "Data"), I = x(p, "SimpleData");
    for (d = 0; d < A.length; d++)
      n[A[d].getAttribute("name") ?? ""] = S(y(A[d], "value")) ?? "";
    for (d = 0; d < I.length; d++)
      n[I[d].getAttribute("name") ?? ""] = S(I[d]) ?? "";
  }
  u !== null && (n.visibility = S(u) ?? ""), a.coordTimes.length !== 0 && (n.coordTimes = a.coordTimes.length === 1 ? a.coordTimes[0] : a.coordTimes);
  const M = {
    type: "Feature",
    geometry: a.geoms.length === 1 ? a.geoms[0] : {
      type: "GeometryCollection",
      geometries: a.geoms
    },
    properties: n
  };
  return K(r, "id") && (M.id = K(r, "id") ?? void 0), [M];
}
function $e(r, e) {
  const t = x(r, e), o = [], a = [];
  let n = [];
  const l = t.length;
  if (!(l < 2)) {
    for (let i = 0; i < l; i++) {
      const c = Ye(t[i]);
      o.push(c.coordinates), c.time && a.push(c.time), (c.heartRate || n.length) && (n.length === 0 && (n = new Array(i).fill(null)), n.push(c.heartRate));
    }
    return {
      line: o,
      times: a,
      heartRates: n
    };
  }
}
function ao(r) {
  const e = x(r, "trkseg"), t = [], o = [], a = [];
  let n;
  for (let i = 0; i < e.length; i++)
    if (n = $e(e[i], "trkpt"), n !== void 0 && (n.line && t.push(n.line), n.times && n.times.length && o.push(n.times), a.length || n.heartRates && n.heartRates.length)) {
      if (!a.length)
        for (let c = 0; c < i; c++)
          a.push(new Array(t[c].length).fill(null));
      n.heartRates && n.heartRates.length ? a.push(n.heartRates) : a.push(new Array(n.line.length).fill(null));
    }
  if (t.length === 0) return;
  const l = {
    ...de(r),
    ...Ke(y(r, "extensions"))
  };
  return o.length !== 0 && (l.coordTimes = t.length === 1 ? o[0] : o), a.length !== 0 && (l.heartRates = t.length === 1 ? a[0] : a), t.length === 1 ? {
    type: "Feature",
    properties: l,
    geometry: {
      type: "LineString",
      coordinates: t[0]
    }
  } : {
    type: "Feature",
    properties: l,
    geometry: {
      type: "MultiLineString",
      coordinates: t
    }
  };
}
function no(r) {
  const e = $e(r, "rtept");
  return e === void 0 ? void 0 : {
    type: "Feature",
    properties: {
      ...de(r),
      ...Ke(y(r, "extensions"))
    },
    geometry: {
      type: "LineString",
      coordinates: e.line
    }
  };
}
function lo(r) {
  return {
    type: "Feature",
    properties: { ...de(r), ...ue(r, ["sym"]) },
    geometry: {
      type: "Point",
      coordinates: Ye(r).coordinates
    }
  };
}
function Ke(r) {
  const e = {};
  if (r) {
    const t = y(r, "line");
    if (t) {
      const o = S(y(t, "color")), a = Number.parseFloat(S(y(t, "opacity")) ?? "0"), n = Number.parseFloat(S(y(t, "width")) ?? "0");
      o && (e.stroke = o), Number.isNaN(a) || (e["stroke-opacity"] = a), Number.isNaN(n) || (e["stroke-width"] = n * 96 / 25.4);
    }
  }
  return e;
}
function de(r) {
  const e = ue(r, [
    "name",
    "cmt",
    "desc",
    "type",
    "time",
    "keywords"
  ]), t = x(r, "link");
  if (t.length !== 0) {
    e.links = [];
    for (const o of Array.from(t)) {
      const a = {
        href: K(o, "href"),
        ...ue(o, ["text", "type"])
      };
      e.links.push(a);
    }
  }
  return e;
}
function Re(r) {
  let e = 0;
  if (!r || !r.length) return e;
  for (let t = 0; t < r.length; t++)
    e = (e << 5) - e + r.charCodeAt(t) | 0;
  return e;
}
function x(r, e) {
  return r.getElementsByTagName(e);
}
function K(r, e) {
  return r.getAttribute(e);
}
function _e(r, e) {
  return Number.parseFloat(K(r, e) ?? "0");
}
function y(r, e) {
  const t = x(r, e);
  return t.length ? t[0] : null;
}
function io(r) {
  return r.normalize && r.normalize(), r;
}
function Ze(r) {
  return r.map(Number.parseFloat).map((e) => Number.isNaN(e) ? null : e);
}
function S(r) {
  return r && io(r), r && r.textContent;
}
function ue(r, e) {
  const t = {};
  let o, a;
  for (a = 0; a < e.length; a++)
    o = y(r, e[a]), o && (t[e[a]] = S(o) ?? "");
  return t;
}
function We(r) {
  return Ze(r.replace(/\s*/g, "").split(","));
}
function xe(r) {
  const e = r.replace(/^\s*|\s*$/g, "").split(/\s+/), t = [];
  for (const o of e) t.push(We(o));
  return t;
}
function Ye(r) {
  const e = [_e(r, "lon"), _e(r, "lat")], t = y(r, "ele"), o = y(r, "gpxtpx:hr") || y(r, "hr"), a = y(r, "time");
  let n;
  return t && (n = Number.parseFloat(S(t) ?? "0"), Number.isNaN(n) || e.push(n)), {
    coordinates: e,
    time: a ? S(a) : null,
    heartRate: o !== null ? Number.parseFloat(S(o) ?? "0") : null
  };
}
function so(r) {
  let e = r;
  try {
    typeof e == "string" && (e = pe(e));
  } catch {
    return null;
  }
  try {
    return Ve(e);
  } catch {
  }
  try {
    return je(e);
  } catch {
  }
  return null;
}
function X(r) {
  const e = r.toString(16);
  return e.length === 1 ? `0${e}` : e;
}
function co(r) {
  return `#${X(r[0])}${X(r[1])}${X(r[2])}${r.length === 4 ? X(r[3]) : ""}`;
}
class g extends Array {
  constructor(t = {}) {
    super();
    T(this, "min", 0);
    T(this, "max", 1);
    "min" in t && (this.min = t.min), "max" in t && (this.max = t.max), "stops" in t && this.setStops(t.stops, { clone: !1 });
  }
  /**
   * Converts a array-definition color ramp definition into a usable ColorRamp instance.
   * Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)
   * @param cr
   * @returns
   */
  static fromArrayDefinition(t) {
    return new g({
      stops: t.map((o) => ({
        value: o[0],
        color: o[1]
      }))
    });
  }
  setStops(t, o = { clone: !0 }) {
    const a = o.clone ? this.clone() : this;
    a.length = 0;
    let n = Number.POSITIVE_INFINITY, l = Number.NEGATIVE_INFINITY;
    for (let i = 0; i < t.length; i += 1)
      n = Math.min(n, t[i].value), l = Math.max(l, t[i].value), a.push({
        value: t[i].value,
        color: t[i].color.slice()
        // we want to make sure we do a deep copy and not a reference
      });
    return a.sort((i, c) => i.value < c.value ? -1 : 1), this.min = n, this.max = l, a;
  }
  scale(t, o, a = { clone: !0 }) {
    const n = a.clone, l = this[0].value, c = this.at(-1).value - l, h = o - t, s = [];
    for (let p = 0; p < this.length; p += 1) {
      const m = (this[p].value - l) / c * h + t;
      n ? s.push({
        value: m,
        color: this[p].color.slice()
      }) : this[p].value = m;
    }
    return n ? new g({ stops: s }) : this;
  }
  // for some reason, I had to reimplement this
  at(t) {
    return t < 0 ? this[this.length + t] : this[t];
  }
  clone() {
    return new g({ stops: this.getRawColorStops() });
  }
  getRawColorStops() {
    const t = [];
    for (let o = 0; o < this.length; o += 1)
      t.push({ value: this[o].value, color: this[o].color });
    return t;
  }
  reverse(t = { clone: !0 }) {
    const o = t.clone ? this.clone() : this;
    for (let a = 0; a < ~~(o.length / 2); a += 1) {
      const n = o[a].color;
      o[a].color = o.at(-(a + 1)).color, o.at(-(a + 1)).color = n;
    }
    return o;
  }
  getBounds() {
    return { min: this.min, max: this.max };
  }
  getColor(t, o = { smooth: !0 }) {
    if (t <= this[0].value)
      return this[0].color;
    if (t >= this.at(-1).value)
      return this.at(-1).color;
    for (let a = 0; a < this.length - 1; a += 1) {
      if (t > this[a + 1].value)
        continue;
      const n = this[a].color;
      if (!o.smooth)
        return n.slice();
      const l = this[a].value, i = this[a + 1].value, c = this[a + 1].color, h = (i - t) / (i - l);
      return n.map(
        (s, p) => Math.round(s * h + c[p] * (1 - h))
      );
    }
    return [0, 0, 0];
  }
  /**
   * Get the color as an hexadecimal string
   */
  getColorHex(t, o = {
    smooth: !0,
    withAlpha: !1
  }) {
    return co(this.getColor(t, o));
  }
  /**
   * Get the color of the color ramp at a relative position in [0, 1]
   */
  getColorRelative(t, o = { smooth: !0 }) {
    const a = this.getBounds();
    return this.getColor(a.min + t * (a.max - a.min), o);
  }
  getCanvasStrip(t = {
    horizontal: !0,
    size: 512,
    smooth: !0
  }) {
    const o = document.createElement("canvas");
    o.width = t.horizontal ? t.size : 1, o.height = t.horizontal ? 1 : t.size;
    const a = o.getContext("2d");
    if (!a) throw new Error("Canvs context is missing");
    const n = a.getImageData(0, 0, o.width, o.height), l = n.data, i = t.size, c = this[0].value, p = (this.at(-1).value - c) / i;
    for (let u = 0; u < i; u += 1) {
      const d = this.getColor(c + u * p, {
        smooth: t.smooth
      });
      l[u * 4] = d[0], l[u * 4 + 1] = d[1], l[u * 4 + 2] = d[2], l[u * 4 + 3] = d.length > 3 ? d[3] : 255;
    }
    return a.putImageData(n, 0, 0), o;
  }
  /**
   * Apply a non-linear ressampling. This will create a new instance of ColorRamp with the same bounds.
   */
  resample(t, o = 15) {
    const a = this.getBounds(), n = this.scale(0, 1), l = 1 / (o - 1);
    let i;
    if (t === "ease-in-square")
      i = Array.from({ length: o }, (s, p) => {
        const u = p * l, d = u ** 2, m = n.getColor(d);
        return { value: u, color: m };
      });
    else if (t === "ease-out-square")
      i = Array.from({ length: o }, (s, p) => {
        const u = p * l, d = 1 - (1 - u) ** 2, m = n.getColor(d);
        return { value: u, color: m };
      });
    else if (t === "ease-out-sqrt")
      i = Array.from({ length: o }, (s, p) => {
        const u = p * l, d = u ** 0.5, m = n.getColor(d);
        return { value: u, color: m };
      });
    else if (t === "ease-in-sqrt")
      i = Array.from({ length: o }, (s, p) => {
        const u = p * l, d = 1 - (1 - u) ** 0.5, m = n.getColor(d);
        return { value: u, color: m };
      });
    else if (t === "ease-out-exp")
      i = Array.from({ length: o }, (s, p) => {
        const u = p * l, d = 1 - 2 ** (-10 * u), m = n.getColor(d);
        return { value: u, color: m };
      });
    else if (t === "ease-in-exp")
      i = Array.from({ length: o }, (s, p) => {
        const u = p * l, d = 2 ** (10 * u - 10), m = n.getColor(d);
        return { value: u, color: m };
      });
    else
      throw new Error("Invalid ressampling method.");
    return new g({ stops: i }).scale(a.min, a.max);
  }
  /**
   * Makes a clone of this color ramp that is fully transparant at the begining of their range
   */
  transparentStart() {
    const t = this.getRawColorStops();
    t.unshift({
      value: t[0].value,
      color: t[0].color.slice()
    }), t[1].value += 1e-3;
    for (const o of t)
      o.color.length === 3 && o.color.push(255);
    return t[0].color[3] = 0, new g({ stops: t });
  }
  /**
   * Check if this color ramp has a transparent start
   */
  hasTransparentStart() {
    return this[0].color.length === 4 && this[0].color[3] === 0;
  }
}
const Je = {
  /**
   * A fully transparent [0, 0, 0, 0] colorramp to hide data.
   * Defined in interval [0, 1], without unit.
   */
  NULL: new g({
    stops: [
      { value: 0, color: [0, 0, 0, 0] },
      { value: 1, color: [0, 0, 0, 0] }
    ]
  }),
  GRAY: new g({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic jet color ramp.
   * Defined in interval [0, 1], without unit.
   */
  JET: new g({
    stops: [
      { value: 0, color: [0, 0, 131] },
      { value: 0.125, color: [0, 60, 170] },
      { value: 0.375, color: [5, 255, 255] },
      { value: 0.625, color: [255, 255, 0] },
      { value: 0.875, color: [250, 0, 0] },
      { value: 1, color: [128, 0, 0] }
    ]
  }),
  /**
   * Classic HSV color ramp (hue, saturation, value).
   * Defined in interval [0, 1], without unit.
   */
  HSV: new g({
    stops: [
      { value: 0, color: [255, 0, 0] },
      { value: 0.169, color: [253, 255, 2] },
      { value: 0.173, color: [247, 255, 2] },
      { value: 0.337, color: [0, 252, 4] },
      { value: 0.341, color: [0, 252, 10] },
      { value: 0.506, color: [1, 249, 255] },
      { value: 0.671, color: [2, 0, 253] },
      { value: 0.675, color: [8, 0, 253] },
      { value: 0.839, color: [255, 0, 251] },
      { value: 0.843, color: [255, 0, 245] },
      { value: 1, color: [255, 0, 6] }
    ]
  }),
  /**
   * Classic hot color ramp.
   * Defined in interval [0, 1], without unit.
   */
  HOT: new g({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.3, color: [230, 0, 0] },
      { value: 0.6, color: [255, 210, 0] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic spring color ramp.
   * Defined in interval [0, 1], without unit.
   */
  SPRING: new g({
    stops: [
      { value: 0, color: [255, 0, 255] },
      { value: 1, color: [255, 255, 0] }
    ]
  }),
  /**
   * Classic summer color ramp.
   * Defined in interval [0, 1], without unit.
   */
  SUMMER: new g({
    stops: [
      { value: 0, color: [0, 128, 102] },
      { value: 1, color: [255, 255, 102] }
    ]
  }),
  /**
   * Classic autommn color ramp.
   * Defined in interval [0, 1], without unit.
   */
  AUTOMN: new g({
    stops: [
      { value: 0, color: [255, 0, 0] },
      { value: 1, color: [255, 255, 0] }
    ]
  }),
  /**
   * Classic winter color ramp.
   * Defined in interval [0, 1], without unit.
   */
  WINTER: new g({
    stops: [
      { value: 0, color: [0, 0, 255] },
      { value: 1, color: [0, 255, 128] }
    ]
  }),
  /**
   * Classic bone color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BONE: new g({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.376, color: [84, 84, 116] },
      { value: 0.753, color: [169, 200, 200] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic copper color ramp.
   * Defined in interval [0, 1], without unit.
   */
  COPPER: new g({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.804, color: [255, 160, 102] },
      { value: 1, color: [255, 199, 127] }
    ]
  }),
  /**
   * Classic greys color ramp.
   * Defined in interval [0, 1], without unit.
   */
  GREYS: new g({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic yignbu color ramp (blue to light yellow).
   * Defined in interval [0, 1], without unit.
   */
  YIGNBU: new g({
    stops: [
      { value: 0, color: [8, 29, 88] },
      { value: 0.125, color: [37, 52, 148] },
      { value: 0.25, color: [34, 94, 168] },
      { value: 0.375, color: [29, 145, 192] },
      { value: 0.5, color: [65, 182, 196] },
      { value: 0.625, color: [127, 205, 187] },
      { value: 0.75, color: [199, 233, 180] },
      { value: 0.875, color: [237, 248, 217] },
      { value: 1, color: [255, 255, 217] }
    ]
  }),
  /**
   * Classic greens color ramp.
   * Defined in interval [0, 1], without unit.
   */
  GREENS: new g({
    stops: [
      { value: 0, color: [0, 68, 27] },
      { value: 0.125, color: [0, 109, 44] },
      { value: 0.25, color: [35, 139, 69] },
      { value: 0.375, color: [65, 171, 93] },
      { value: 0.5, color: [116, 196, 118] },
      { value: 0.625, color: [161, 217, 155] },
      { value: 0.75, color: [199, 233, 192] },
      { value: 0.875, color: [229, 245, 224] },
      { value: 1, color: [247, 252, 245] }
    ]
  }),
  /**
   * Classic yiorrd color ramp (red to light yellow).
   * Defined in interval [0, 1], without unit.
   */
  YIORRD: new g({
    stops: [
      { value: 0, color: [128, 0, 38] },
      { value: 0.125, color: [189, 0, 38] },
      { value: 0.25, color: [227, 26, 28] },
      { value: 0.375, color: [252, 78, 42] },
      { value: 0.5, color: [253, 141, 60] },
      { value: 0.625, color: [254, 178, 76] },
      { value: 0.75, color: [254, 217, 118] },
      { value: 0.875, color: [255, 237, 160] },
      { value: 1, color: [255, 255, 204] }
    ]
  }),
  /**
   * Classic blue-red color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BLUERED: new g({
    stops: [
      { value: 0, color: [0, 0, 255] },
      { value: 1, color: [255, 0, 0] }
    ]
  }),
  /**
   * Classic rdbu color ramp.
   * Defined in interval [0, 1], without unit.
   */
  RDBU: new g({
    stops: [
      { value: 0, color: [5, 10, 172] },
      { value: 0.35, color: [106, 137, 247] },
      { value: 0.5, color: [190, 190, 190] },
      { value: 0.6, color: [220, 170, 132] },
      { value: 0.7, color: [230, 145, 90] },
      { value: 1, color: [178, 10, 28] }
    ]
  }),
  /**
   * Classic picnic color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PICNIC: new g({
    stops: [
      { value: 0, color: [0, 0, 255] },
      { value: 0.1, color: [51, 153, 255] },
      { value: 0.2, color: [102, 204, 255] },
      { value: 0.3, color: [153, 204, 255] },
      { value: 0.4, color: [204, 204, 255] },
      { value: 0.5, color: [255, 255, 255] },
      { value: 0.6, color: [255, 204, 255] },
      { value: 0.7, color: [255, 153, 255] },
      { value: 0.8, color: [255, 102, 204] },
      { value: 0.9, color: [255, 102, 102] },
      { value: 1, color: [255, 0, 0] }
    ]
  }),
  /**
   * Classic rainbow color ramp.
   * Defined in interval [0, 1], without unit.
   */
  RAINBOW: new g({
    stops: [
      { value: 0, color: [150, 0, 90] },
      { value: 0.125, color: [0, 0, 200] },
      { value: 0.25, color: [0, 25, 255] },
      { value: 0.375, color: [0, 152, 255] },
      { value: 0.5, color: [44, 255, 150] },
      { value: 0.625, color: [151, 255, 0] },
      { value: 0.75, color: [255, 234, 0] },
      { value: 0.875, color: [255, 111, 0] },
      { value: 1, color: [255, 0, 0] }
    ]
  }),
  /**
   * Classic Portland color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PORTLAND: new g({
    stops: [
      { value: 0, color: [12, 51, 131] },
      { value: 0.25, color: [10, 136, 186] },
      { value: 0.5, color: [242, 211, 56] },
      { value: 0.75, color: [242, 143, 56] },
      { value: 1, color: [217, 30, 30] }
    ]
  }),
  /**
   * Classic blackbody color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BLACKBODY: new g({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.2, color: [230, 0, 0] },
      { value: 0.4, color: [230, 210, 0] },
      { value: 0.7, color: [255, 255, 255] },
      { value: 1, color: [160, 200, 255] }
    ]
  }),
  /**
   * Classic earth color ramp.
   * Defined in interval [0, 1], without unit.
   */
  EARTH: new g({
    stops: [
      { value: 0, color: [0, 0, 130] },
      { value: 0.1, color: [0, 180, 180] },
      { value: 0.2, color: [40, 210, 40] },
      { value: 0.4, color: [230, 230, 50] },
      { value: 0.6, color: [120, 70, 20] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic electric color ramp.
   * Defined in interval [0, 1], without unit.
   */
  ELECTRIC: new g({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.15, color: [30, 0, 100] },
      { value: 0.4, color: [120, 0, 100] },
      { value: 0.6, color: [160, 90, 0] },
      { value: 0.8, color: [230, 200, 0] },
      { value: 1, color: [255, 250, 220] }
    ]
  }),
  /**
   * Classic viridis color ramp.
   * Defined in interval [0, 1], without unit.
   */
  VIRIDIS: new g({
    stops: [
      { value: 0, color: [68, 1, 84] },
      { value: 0.13, color: [71, 44, 122] },
      { value: 0.25, color: [59, 81, 139] },
      { value: 0.38, color: [44, 113, 142] },
      { value: 0.5, color: [33, 144, 141] },
      { value: 0.63, color: [39, 173, 129] },
      { value: 0.75, color: [92, 200, 99] },
      { value: 0.88, color: [170, 220, 50] },
      { value: 1, color: [253, 231, 37] }
    ]
  }),
  /**
   * Classic inferno color ramp.
   * Defined in interval [0, 1], without unit.
   */
  INFERNO: new g({
    stops: [
      { value: 0, color: [0, 0, 4] },
      { value: 0.13, color: [31, 12, 72] },
      { value: 0.25, color: [85, 15, 109] },
      { value: 0.38, color: [136, 34, 106] },
      { value: 0.5, color: [186, 54, 85] },
      { value: 0.63, color: [227, 89, 51] },
      { value: 0.75, color: [249, 140, 10] },
      { value: 0.88, color: [249, 201, 50] },
      { value: 1, color: [252, 255, 164] }
    ]
  }),
  /**
   * Classic magma color ramp.
   * Defined in interval [0, 1], without unit.
   */
  MAGMA: new g({
    stops: [
      { value: 0, color: [0, 0, 4] },
      { value: 0.13, color: [28, 16, 68] },
      { value: 0.25, color: [79, 18, 123] },
      { value: 0.38, color: [129, 37, 129] },
      { value: 0.5, color: [181, 54, 122] },
      { value: 0.63, color: [229, 80, 100] },
      { value: 0.75, color: [251, 135, 97] },
      { value: 0.88, color: [254, 194, 135] },
      { value: 1, color: [252, 253, 191] }
    ]
  }),
  /**
   * Classic plasma color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PLASMA: new g({
    stops: [
      { value: 0, color: [13, 8, 135] },
      { value: 0.13, color: [75, 3, 161] },
      { value: 0.25, color: [125, 3, 168] },
      { value: 0.38, color: [168, 34, 150] },
      { value: 0.5, color: [203, 70, 121] },
      { value: 0.63, color: [229, 107, 93] },
      { value: 0.75, color: [248, 148, 65] },
      { value: 0.88, color: [253, 195, 40] },
      { value: 1, color: [240, 249, 33] }
    ]
  }),
  /**
   * Classic warm color ramp.
   * Defined in interval [0, 1], without unit.
   */
  WARM: new g({
    stops: [
      { value: 0, color: [125, 0, 179] },
      { value: 0.13, color: [172, 0, 187] },
      { value: 0.25, color: [219, 0, 170] },
      { value: 0.38, color: [255, 0, 130] },
      { value: 0.5, color: [255, 63, 74] },
      { value: 0.63, color: [255, 123, 0] },
      { value: 0.75, color: [234, 176, 0] },
      { value: 0.88, color: [190, 228, 0] },
      { value: 1, color: [147, 255, 0] }
    ]
  }),
  /**
   * Classic cool color ramp.
   * Defined in interval [0, 1], without unit.
   */
  COOL: new g({
    stops: [
      { value: 0, color: [125, 0, 179] },
      { value: 0.13, color: [116, 0, 218] },
      { value: 0.25, color: [98, 74, 237] },
      { value: 0.38, color: [68, 146, 231] },
      { value: 0.5, color: [0, 204, 197] },
      { value: 0.63, color: [0, 247, 146] },
      { value: 0.75, color: [0, 255, 88] },
      { value: 0.88, color: [40, 255, 8] },
      { value: 1, color: [147, 255, 0] }
    ]
  }),
  /**
   * Classic rainboz soft color ramp.
   * Defined in interval [0, 1], without unit.
   */
  RAINBOW_SOFT: new g({
    stops: [
      { value: 0, color: [125, 0, 179] },
      { value: 0.1, color: [199, 0, 180] },
      { value: 0.2, color: [255, 0, 121] },
      { value: 0.3, color: [255, 108, 0] },
      { value: 0.4, color: [222, 194, 0] },
      { value: 0.5, color: [150, 255, 0] },
      { value: 0.6, color: [0, 255, 55] },
      { value: 0.7, color: [0, 246, 150] },
      { value: 0.8, color: [50, 167, 222] },
      { value: 0.9, color: [103, 51, 235] },
      { value: 1, color: [124, 0, 186] }
    ]
  }),
  /**
   * Classic bathymetry color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BATHYMETRY: new g({
    stops: [
      { value: 0, color: [40, 26, 44] },
      { value: 0.13, color: [59, 49, 90] },
      { value: 0.25, color: [64, 76, 139] },
      { value: 0.38, color: [63, 110, 151] },
      { value: 0.5, color: [72, 142, 158] },
      { value: 0.63, color: [85, 174, 163] },
      { value: 0.75, color: [120, 206, 163] },
      { value: 0.88, color: [187, 230, 172] },
      { value: 1, color: [253, 254, 204] }
    ]
  }),
  /**
   * Classic cdom color ramp.
   * Defined in interval [0, 1], without unit.
   */
  CDOM: new g({
    stops: [
      { value: 0, color: [47, 15, 62] },
      { value: 0.13, color: [87, 23, 86] },
      { value: 0.25, color: [130, 28, 99] },
      { value: 0.38, color: [171, 41, 96] },
      { value: 0.5, color: [206, 67, 86] },
      { value: 0.63, color: [230, 106, 84] },
      { value: 0.75, color: [242, 149, 103] },
      { value: 0.88, color: [249, 193, 135] },
      { value: 1, color: [254, 237, 176] }
    ]
  }),
  /**
   * Classic chlorophyll color ramp.
   * Defined in interval [0, 1], without unit.
   */
  CHLOROPHYLL: new g({
    stops: [
      { value: 0, color: [18, 36, 20] },
      { value: 0.13, color: [25, 63, 41] },
      { value: 0.25, color: [24, 91, 59] },
      { value: 0.38, color: [13, 119, 72] },
      { value: 0.5, color: [18, 148, 80] },
      { value: 0.63, color: [80, 173, 89] },
      { value: 0.75, color: [132, 196, 122] },
      { value: 0.88, color: [175, 221, 162] },
      { value: 1, color: [215, 249, 208] }
    ]
  }),
  /**
   * Classic density color ramp.
   * Defined in interval [0, 1], without unit.
   */
  DENSITY: new g({
    stops: [
      { value: 0, color: [54, 14, 36] },
      { value: 0.13, color: [89, 23, 80] },
      { value: 0.25, color: [110, 45, 132] },
      { value: 0.38, color: [120, 77, 178] },
      { value: 0.5, color: [120, 113, 213] },
      { value: 0.63, color: [115, 151, 228] },
      { value: 0.75, color: [134, 185, 227] },
      { value: 0.88, color: [177, 214, 227] },
      { value: 1, color: [230, 241, 241] }
    ]
  }),
  /**
   * Classic freesurface blue color ramp.
   * Defined in interval [0, 1], without unit.
   */
  FREESURFACE_BLUE: new g({
    stops: [
      { value: 0, color: [30, 4, 110] },
      { value: 0.13, color: [47, 14, 176] },
      { value: 0.25, color: [41, 45, 236] },
      { value: 0.38, color: [25, 99, 212] },
      { value: 0.5, color: [68, 131, 200] },
      { value: 0.63, color: [114, 156, 197] },
      { value: 0.75, color: [157, 181, 203] },
      { value: 0.88, color: [200, 208, 216] },
      { value: 1, color: [241, 237, 236] }
    ]
  }),
  /**
   * Classic freesurface red color ramp.
   * Defined in interval [0, 1], without unit.
   */
  FREESURFACE_RED: new g({
    stops: [
      { value: 0, color: [60, 9, 18] },
      { value: 0.13, color: [100, 17, 27] },
      { value: 0.25, color: [142, 20, 29] },
      { value: 0.38, color: [177, 43, 27] },
      { value: 0.5, color: [192, 87, 63] },
      { value: 0.63, color: [205, 125, 105] },
      { value: 0.75, color: [216, 162, 148] },
      { value: 0.88, color: [227, 199, 193] },
      { value: 1, color: [241, 237, 236] }
    ]
  }),
  /**
   * Classic oxygen color ramp.
   * Defined in interval [0, 1], without unit.
   */
  OXYGEN: new g({
    stops: [
      { value: 0, color: [64, 5, 5] },
      { value: 0.13, color: [106, 6, 15] },
      { value: 0.25, color: [144, 26, 7] },
      { value: 0.38, color: [168, 64, 3] },
      { value: 0.5, color: [188, 100, 4] },
      { value: 0.63, color: [206, 136, 11] },
      { value: 0.75, color: [220, 174, 25] },
      { value: 0.88, color: [231, 215, 44] },
      { value: 1, color: [248, 254, 105] }
    ]
  }),
  /**
   * Classic par color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PAR: new g({
    stops: [
      { value: 0, color: [51, 20, 24] },
      { value: 0.13, color: [90, 32, 35] },
      { value: 0.25, color: [129, 44, 34] },
      { value: 0.38, color: [159, 68, 25] },
      { value: 0.5, color: [182, 99, 19] },
      { value: 0.63, color: [199, 134, 22] },
      { value: 0.75, color: [212, 171, 35] },
      { value: 0.88, color: [221, 210, 54] },
      { value: 1, color: [225, 253, 75] }
    ]
  }),
  /**
   * Classic phase color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PHASE: new g({
    stops: [
      { value: 0, color: [145, 105, 18] },
      { value: 0.13, color: [184, 71, 38] },
      { value: 0.25, color: [186, 58, 115] },
      { value: 0.38, color: [160, 71, 185] },
      { value: 0.5, color: [110, 97, 218] },
      { value: 0.63, color: [50, 123, 164] },
      { value: 0.75, color: [31, 131, 110] },
      { value: 0.88, color: [77, 129, 34] },
      { value: 1, color: [145, 105, 18] }
    ]
  }),
  /**
   * Classic salinity color ramp.
   * Defined in interval [0, 1], without unit.
   */
  SALINITY: new g({
    stops: [
      { value: 0, color: [42, 24, 108] },
      { value: 0.13, color: [33, 50, 162] },
      { value: 0.25, color: [15, 90, 145] },
      { value: 0.38, color: [40, 118, 137] },
      { value: 0.5, color: [59, 146, 135] },
      { value: 0.63, color: [79, 175, 126] },
      { value: 0.75, color: [120, 203, 104] },
      { value: 0.88, color: [193, 221, 100] },
      { value: 1, color: [253, 239, 154] }
    ]
  }),
  /**
   * Classic temperature color ramp.
   * Defined in interval [0, 1], without unit.
   */
  TEMPERATURE: new g({
    stops: [
      { value: 0, color: [4, 35, 51] },
      { value: 0.13, color: [23, 51, 122] },
      { value: 0.25, color: [85, 59, 157] },
      { value: 0.38, color: [129, 79, 143] },
      { value: 0.5, color: [175, 95, 130] },
      { value: 0.63, color: [222, 112, 101] },
      { value: 0.75, color: [249, 146, 66] },
      { value: 0.88, color: [249, 196, 65] },
      { value: 1, color: [232, 250, 91] }
    ]
  }),
  /**
   * Classic turbidity color ramp.
   * Defined in interval [0, 1], without unit.
   */
  TURBIDITY: new g({
    stops: [
      { value: 0, color: [34, 31, 27] },
      { value: 0.13, color: [65, 50, 41] },
      { value: 0.25, color: [98, 69, 52] },
      { value: 0.38, color: [131, 89, 57] },
      { value: 0.5, color: [161, 112, 59] },
      { value: 0.63, color: [185, 140, 66] },
      { value: 0.75, color: [202, 174, 88] },
      { value: 0.88, color: [216, 209, 126] },
      { value: 1, color: [233, 246, 171] }
    ]
  }),
  /**
   * Classic velocity blue color ramp.
   * Defined in interval [0, 1], without unit.
   */
  VELOCITY_BLUE: new g({
    stops: [
      { value: 0, color: [17, 32, 64] },
      { value: 0.13, color: [35, 52, 116] },
      { value: 0.25, color: [29, 81, 156] },
      { value: 0.38, color: [31, 113, 162] },
      { value: 0.5, color: [50, 144, 169] },
      { value: 0.63, color: [87, 173, 176] },
      { value: 0.75, color: [149, 196, 189] },
      { value: 0.88, color: [203, 221, 211] },
      { value: 1, color: [254, 251, 230] }
    ]
  }),
  /**
   * Classic velocity green color ramp.
   * Defined in interval [0, 1], without unit.
   */
  VELOCITY_GREEN: new g({
    stops: [
      { value: 0, color: [23, 35, 19] },
      { value: 0.13, color: [24, 64, 38] },
      { value: 0.25, color: [11, 95, 45] },
      { value: 0.38, color: [39, 123, 35] },
      { value: 0.5, color: [95, 146, 12] },
      { value: 0.63, color: [152, 165, 18] },
      { value: 0.75, color: [201, 186, 69] },
      { value: 0.88, color: [233, 216, 137] },
      { value: 1, color: [255, 253, 205] }
    ]
  }),
  /**
   * Classic cube helix color ramp.
   * Defined in interval [0, 1], without unit.
   */
  CUBEHELIX: new g({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.07, color: [22, 5, 59] },
      { value: 0.13, color: [60, 4, 105] },
      { value: 0.2, color: [109, 1, 135] },
      { value: 0.27, color: [161, 0, 147] },
      { value: 0.33, color: [210, 2, 142] },
      { value: 0.4, color: [251, 11, 123] },
      { value: 0.47, color: [255, 29, 97] },
      { value: 0.53, color: [255, 54, 69] },
      { value: 0.6, color: [255, 85, 46] },
      { value: 0.67, color: [255, 120, 34] },
      { value: 0.73, color: [255, 157, 37] },
      { value: 0.8, color: [241, 191, 57] },
      { value: 0.87, color: [224, 220, 93] },
      { value: 0.93, color: [218, 241, 142] },
      { value: 1, color: [227, 253, 198] }
    ]
  }),
  /**
   * The cividis color ramp is color blind friendly.
   * Read more here https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239
   * Defined in interval [0, 1], without unit.
   */
  CIVIDIS: new g({
    stops: [
      { value: 0, color: [0, 32, 77, 255] },
      { value: 0.125, color: [5, 54, 110, 255] },
      { value: 0.25, color: [65, 77, 108, 255] },
      { value: 0.375, color: [97, 100, 111, 255] },
      { value: 0.5, color: [125, 124, 121, 255] },
      { value: 0.625, color: [156, 149, 120, 255] },
      { value: 0.75, color: [190, 175, 111, 255] },
      { value: 0.875, color: [225, 204, 94, 255] },
      { value: 1, color: [255, 235, 70, 255] }
    ]
  }),
  /**
   * Classic turbo color ramp.
   * This is a luminance-constant alternative to the jet, making it more
   * clor-blind friendly.
   * Defined in interval [0, 1], without unit.
   */
  TURBO: new g({
    stops: [
      { value: 0, color: [48, 18, 59, 255] },
      { value: 0.125, color: [70, 107, 227, 255] },
      { value: 0.25, color: [40, 187, 236, 255] },
      { value: 0.375, color: [49, 242, 153, 255] },
      { value: 0.5, color: [162, 252, 60, 255] },
      { value: 0.625, color: [237, 208, 58, 255] },
      { value: 0.75, color: [251, 128, 34, 255] },
      { value: 0.875, color: [210, 49, 5, 255] },
      { value: 1, color: [122, 4, 3, 255] }
    ]
  }),
  /**
   * The rocket color ramp is perceptually uniform, which makes it more
   * color bliend friendly than the classic magma color ramp.
   * Defined in interval [0, 1], without unit.
   */
  ROCKET: new g({
    stops: [
      { value: 0, color: [250, 235, 221, 0] },
      { value: 0.133, color: [250, 235, 221, 255] },
      { value: 0.266, color: [246, 170, 130, 255] },
      { value: 0.4, color: [240, 96, 67, 255] },
      { value: 0.533, color: [203, 27, 79, 255] },
      { value: 0.666, color: [132, 30, 90, 255] },
      { value: 0.8, color: [63, 27, 68, 255] },
      { value: 1, color: [3, 5, 26, 255] }
    ]
  }),
  /**
   * The mako color ramp is perceptually uniform and can be seen as
   * a color blind friendly alternative to bathymetry or yignbu.
   * Defined in interval [0, 1], without unit.
   */
  MAKO: new g({
    stops: [
      { value: 0, color: [11, 4, 5, 255] },
      { value: 0.125, color: [43, 28, 53, 255] },
      { value: 0.25, color: [62, 53, 107, 255] },
      { value: 0.375, color: [59, 86, 152, 255] },
      { value: 0.5, color: [53, 123, 162, 255] },
      { value: 0.625, color: [53, 158, 170, 255] },
      { value: 0.75, color: [73, 193, 173, 255] },
      { value: 0.875, color: [150, 221, 181, 255] },
      { value: 1, color: [222, 245, 229, 255] }
    ]
  })
}, Ne = [
  // https://colorhunt.co/palette/1d5b79468b97ef6262f3aa60
  ["#1D5B79", "#468B97", "#EF6262", "#F3AA60"],
  // https://colorhunt.co/palette/614bc333bbc585e6c5c8ffe0
  ["#614BC3", "#33BBC5", "#85E6C5", "#C8FFE0"],
  // https://colorhunt.co/palette/4619597a316fcd6688aed8cc
  ["#461959", "#7A316F", "#CD6688", "#AED8CC"],
  // https://colorhunt.co/palette/0079ff00dfa2f6fa70ff0060
  ["#0079FF", "#00DFA2", "#F6FA70", "#FF0060"],
  //https://colorhunt.co/palette/39b5e0a31acbff78f0f5ea5a
  ["#39B5E0", "#A31ACB", "#FF78F0", "#F5EA5A"],
  // https://colorhunt.co/palette/37e2d5590696c70a80fbcb0a
  ["#37E2D5", "#590696", "#C70A80", "#FBCB0A"],
  // https://colorhunt.co/palette/ffd36efff56d99ffcd9fb4ff
  ["#FFD36E", "#FFF56D", "#99FFCD", "#9FB4FF"],
  // https://colorhunt.co/palette/00ead3fff5b7ff449f005f99
  ["#00EAD3", "#FFF5B7", "#FF449F", "#005F99"],
  // https://colorhunt.co/palette/10a19d540375ff7000ffbf00
  ["#10A19D", "#540375", "#FF7000", "#FFBF00"]
];
function he() {
  return Ne[~~(Math.random() * Ne.length)][~~(Math.random() * 4)];
}
function te() {
  return `maptiler_source_${Ue()}`;
}
function oe() {
  return `maptiler_layer_${Ue()}`;
}
function Me(r, e) {
  if (e <= r[0].zoom)
    return r[0].value;
  if (e >= r[r.length - 1].zoom)
    return r[r.length - 1].value;
  for (let t = 0; t < r.length - 1; t += 1)
    if (e >= r[t].zoom && e < r[t + 1].zoom) {
      const o = r[t + 1].zoom - r[t].zoom, a = (e - r[t].zoom) / o;
      return a * r[t + 1].value + (1 - a) * r[t].value;
    }
  return 0;
}
function Z(r) {
  return ["interpolate", ["linear"], ["zoom"], ...r.flatMap((e) => [e.zoom, e.value])];
}
function b(r) {
  return ["interpolate", ["linear"], ["zoom"], ...r.flatMap((e) => [e.zoom, e.value])];
}
function uo(r, e) {
  if (typeof e == "number" && typeof r == "number")
    return 2 * e + r;
  if (typeof e == "number" && Array.isArray(r))
    return ["interpolate", ["linear"], ["zoom"], ...r.flatMap((t) => [t.zoom, 2 * e + t.value])];
  if (typeof r == "number" && Array.isArray(e))
    return ["interpolate", ["linear"], ["zoom"], ...e.flatMap((t) => [t.zoom, 2 * t.value + r])];
  if (Array.isArray(r) && Array.isArray(e)) {
    const t = Array.from(
      /* @__PURE__ */ new Set([...r.map((o) => o.zoom), ...e.map((o) => o.zoom)])
    ).sort((o, a) => o < a ? -1 : 1);
    return [
      "interpolate",
      ["linear"],
      ["zoom"],
      ...t.flatMap((o) => [o, 2 * Me(e, o) + Me(r, o)])
    ];
  }
  return 0;
}
function po(r, e) {
  return ["interpolate", ["linear"], ["get", e], ...r.flatMap((t) => [t.propertyValue, t.value])];
}
function qe(r) {
  const e = r.trimStart(), t = `${e}${" ".repeat(r.length - e.length)}`, o = Array.from(t);
  if (!o.every((i) => i === " " || i === "_"))
    throw new Error("A dash pattern must be composed only of whitespace and underscore characters.");
  if (!(o.some((i) => i === "_") && o.some((i) => i === " ")))
    throw new Error("A dash pattern must contain at least one underscore and one whitespace character");
  const l = [1];
  for (let i = 1; i < o.length; i += 1) {
    const c = o[i - 1], h = o[i];
    c === h ? l[l.length - 1] += 1 : l.push(1);
  }
  return l;
}
function Pe(r, e) {
  return ["interpolate", ["linear"], ["get", e], ...r.flatMap((t) => [t.value, t.color])];
}
function Oe(r, e, t = !0) {
  return t ? [
    "interpolate",
    ["linear"],
    ["zoom"],
    0,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((o) => [o.value, o.pointRadius * 0.025])],
    2,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((o) => [o.value, o.pointRadius * 0.05])],
    4,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((o) => [o.value, o.pointRadius * 0.1])],
    8,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((o) => [o.value, o.pointRadius * 0.25])],
    16,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((o) => [o.value, o.pointRadius])]
  ] : ["interpolate", ["linear"], ["get", e], ...r.flatMap((o) => [o.value, o.pointRadius])];
}
function ho(r, e, t = !0) {
  return t ? [
    "interpolate",
    ["linear"],
    ["zoom"],
    0,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((o) => [o.propertyValue, o.value * 0.025])],
    2,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((o) => [o.propertyValue, o.value * 0.05])],
    4,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((o) => [o.propertyValue, o.value * 0.1])],
    8,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((o) => [o.propertyValue, o.value * 0.25])],
    16,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((o) => [o.propertyValue, o.value])]
  ] : ["interpolate", ["linear"], ["get", e], ...r.flatMap((o) => [o.propertyValue, o.value])];
}
function ke(r, e) {
  return r.every((t) => t.color[3] === r[0].color[3]) ? r[0].color[3] ? r[0].color[3] / 255 : 1 : [
    "interpolate",
    ["linear"],
    ["get", e],
    ...r.getRawColorStops().flatMap((t) => {
      const o = t.value, a = t.color;
      return [o, a.length === 4 ? a[3] / 255 : 1];
    })
  ];
}
function mo(r, e = 10) {
  return [
    "interpolate",
    ["linear"],
    ["heatmap-density"],
    ...Array.from({ length: e + 1 }, (t, o) => {
      const a = o / e;
      return [a, r.getColorHex(a)];
    }).flat()
  ];
}
async function fo(r, e, t = {}) {
  var a, n;
  if (!e.sourceId && !e.data)
    throw new Error("Creating a polyline layer requires an existing .sourceId or a valid .data property");
  let o = e.data;
  if (typeof o == "string") {
    if (ee(o))
      o = `https://api.maptiler.com/data/${e.data}/features.json?key=${N.apiKey}`;
    else if (((a = o.split(".").pop()) == null ? void 0 : a.toLowerCase().trim()) === "gpx") {
      const i = await (await fetch(o, t)).text();
      o = Ve(i);
    } else if (((n = o.split(".").pop()) == null ? void 0 : n.toLowerCase().trim()) === "kml") {
      const i = await (await fetch(o, t)).text();
      o = je(i);
    } else {
      const l = Ht(o) ?? so(o);
      l && (o = l);
    }
    if (!o)
      throw new Error("Polyline data was provided as string but is incompatible with valid formats.");
  }
  return go(r, {
    ...e,
    data: o
  });
}
function go(r, e) {
  if (e.layerId && r.getLayer(e.layerId))
    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
  const t = e.sourceId ?? te(), o = e.layerId ?? oe(), a = {
    polylineLayerId: o,
    polylineOutlineLayerId: "",
    polylineSourceId: t
  };
  e.data && !r.getSource(t) && r.addSource(t, {
    type: "geojson",
    data: e.data
  });
  const n = e.lineWidth ?? 3, l = e.lineColor ?? he(), i = e.lineOpacity ?? 1, c = e.lineBlur ?? 0, h = e.lineGapWidth ?? 0;
  let s = e.lineDashArray ?? null;
  const p = e.outlineWidth ?? 1, u = e.outlineColor ?? "#FFFFFF", d = e.outlineOpacity ?? 1, m = e.outlineBlur ?? 0;
  if (typeof s == "string" && (s = qe(s)), e.outline === !0) {
    const v = `${o}_outline`;
    a.polylineOutlineLayerId = v, r.addLayer(
      {
        id: v,
        type: "line",
        source: t,
        layout: {
          "line-join": e.lineJoin ?? "round",
          "line-cap": e.lineCap ?? "round"
        },
        minzoom: e.minzoom ?? 0,
        maxzoom: e.maxzoom ?? 23,
        paint: {
          "line-opacity": typeof d == "number" ? d : b(d),
          "line-color": typeof u == "string" ? u : Z(u),
          "line-width": uo(n, p),
          "line-blur": typeof m == "number" ? m : b(m)
        }
      },
      e.beforeId
    );
  }
  return r.addLayer(
    {
      id: o,
      type: "line",
      source: t,
      layout: {
        "line-join": e.lineJoin ?? "round",
        "line-cap": e.lineCap ?? "round"
      },
      minzoom: e.minzoom ?? 0,
      maxzoom: e.maxzoom ?? 23,
      paint: {
        "line-opacity": typeof i == "number" ? i : b(i),
        "line-color": typeof l == "string" ? l : Z(l),
        "line-width": typeof n == "number" ? n : b(n),
        "line-blur": typeof c == "number" ? c : b(c),
        "line-gap-width": typeof h == "number" ? h : b(h),
        // For some reasons passing "line-dasharray" with the value "undefined"
        // results in no showing the line while it should have the same behavior
        // of not adding the property "line-dasharray" as all.
        // As a workaround, we are inlining the addition of the prop with a conditional
        // which is less readable.
        ...s && { "line-dasharray": s }
      }
    },
    e.beforeId
  ), a;
}
function yo(r, e) {
  if (e.layerId && r.getLayer(e.layerId))
    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
  const t = e.sourceId ?? te(), o = e.layerId ?? oe(), a = {
    polygonLayerId: o,
    polygonOutlineLayerId: e.outline ? `${o}_outline` : "",
    polygonSourceId: t
  };
  if (e.data && !r.getSource(t)) {
    let v = e.data;
    typeof v == "string" && ee(v) && (v = `https://api.maptiler.com/data/${v}/features.json?key=${N.apiKey}`), r.addSource(t, {
      type: "geojson",
      data: v
    });
  }
  let n = e.outlineDashArray ?? null;
  const l = e.outlineWidth ?? 1, i = e.outlineColor ?? "#FFFFFF", c = e.outlineOpacity ?? 1, h = e.outlineBlur ?? 0, s = e.fillColor ?? he(), p = e.fillOpacity ?? 1, u = e.outlinePosition ?? "center", d = e.pattern ?? null;
  typeof n == "string" && (n = qe(n));
  const m = (v = null) => {
    if (r.addLayer(
      {
        id: o,
        type: "fill",
        source: t,
        minzoom: e.minzoom ?? 0,
        maxzoom: e.maxzoom ?? 23,
        paint: {
          "fill-color": typeof s == "string" ? s : Z(s),
          "fill-opacity": typeof p == "number" ? p : b(p),
          // Adding a pattern if provided
          ...v && { "fill-pattern": v }
        }
      },
      e.beforeId
    ), e.outline === !0) {
      let w;
      u === "inside" ? typeof l == "number" ? w = 0.5 * l : w = b(
        l.map(({ zoom: M, value: A }) => ({
          zoom: M,
          value: 0.5 * A
        }))
      ) : u === "outside" ? typeof l == "number" ? w = -0.5 * l : w = b(
        l.map((M) => ({
          zoom: M.zoom,
          value: -0.5 * M.value
        }))
      ) : w = 0, r.addLayer(
        {
          id: a.polygonOutlineLayerId,
          type: "line",
          source: t,
          layout: {
            "line-join": e.outlineJoin ?? "round",
            "line-cap": e.outlineCap ?? "butt"
          },
          minzoom: e.minzoom ?? 0,
          maxzoom: e.maxzoom ?? 23,
          paint: {
            "line-opacity": typeof c == "number" ? c : b(c),
            "line-color": typeof i == "string" ? i : Z(i),
            "line-width": typeof l == "number" ? l : b(l),
            "line-blur": typeof h == "number" ? h : b(h),
            "line-offset": w,
            // For some reasons passing "line-dasharray" with the value "undefined"
            // results in no showing the line while it should have the same behavior
            // of not adding the property "line-dasharray" as all.
            // As a workaround, we are inlining the addition of the prop with a conditional
            // which is less readable.
            ...n && {
              "line-dasharray": n
            }
          }
        },
        e.beforeId
      );
    }
  };
  return d ? r.hasImage(d) ? m(d) : r.loadImage(d).then((v) => {
    r.addImage(d, v.data), m(d);
  }).catch((v) => (console.error("Could not load the pattern image.", v.message), m())) : m(), a;
}
function vo(r, e) {
  if (e.layerId && r.getLayer(e.layerId))
    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
  const t = e.minPointRadius ?? 10, o = e.maxPointRadius ?? 50, a = e.cluster ?? !1, n = 20, l = Array.isArray(e.pointColor) ? e.pointColor : Je.TURBO.scale(10, e.cluster ? 1e4 : 1e3).resample("ease-out-square"), i = l.getBounds(), c = e.sourceId ?? te(), h = e.layerId ?? oe(), s = e.showLabel ?? a, p = e.alignOnViewport ?? !0, u = e.outline ?? !1, d = e.outlineOpacity ?? 1, m = e.outlineWidth ?? 1, v = e.outlineColor ?? "#FFFFFF";
  let w;
  const M = e.zoomCompensation ?? !0, A = e.minzoom ?? 0, I = e.maxzoom ?? 23;
  typeof e.pointOpacity == "number" ? w = e.pointOpacity : Array.isArray(e.pointOpacity) ? w = b(e.pointOpacity) : e.cluster ? w = ke(l, "point_count") : e.property ? w = ke(l, e.property) : w = b([
    { zoom: A, value: 0 },
    { zoom: A + 0.25, value: 1 },
    { zoom: I - 0.25, value: 1 },
    { zoom: I, value: 0 }
  ]);
  const R = {
    pointLayerId: h,
    clusterLayerId: "",
    labelLayerId: "",
    pointSourceId: c
  };
  if (e.data && !r.getSource(c)) {
    let E = e.data;
    typeof E == "string" && ee(E) && (E = `https://api.maptiler.com/data/${E}/features.json?key=${N.apiKey}`), r.addSource(c, {
      type: "geojson",
      data: E,
      cluster: a
    });
  }
  if (a) {
    R.clusterLayerId = `${h}_cluster`;
    const E = Array.from({ length: n }, (U, j) => {
      const W = i.min + j * (i.max - i.min) / (n - 1);
      return {
        value: W,
        pointRadius: t + (o - t) * (j / (n - 1)) ** 0.5,
        color: l.getColorHex(W)
      };
    });
    r.addLayer(
      {
        id: R.clusterLayerId,
        type: "circle",
        source: c,
        filter: ["has", "point_count"],
        paint: {
          // 'circle-color': options.pointColor ?? colorDrivenByProperty(clusterStyle, "point_count"),
          "circle-color": typeof e.pointColor == "string" ? e.pointColor : Pe(E, "point_count"),
          "circle-radius": typeof e.pointRadius == "number" ? e.pointRadius : Array.isArray(e.pointRadius) ? b(e.pointRadius) : Oe(E, "point_count", !1),
          "circle-pitch-alignment": p ? "viewport" : "map",
          "circle-pitch-scale": "map",
          // scale with camera distance regardless of viewport/biewport alignement
          "circle-opacity": w,
          ...u && {
            "circle-stroke-opacity": typeof d == "number" ? d : b(d),
            "circle-stroke-width": typeof m == "number" ? m : b(m),
            "circle-stroke-color": typeof v == "string" ? v : Z(v)
          }
        },
        minzoom: A,
        maxzoom: I
      },
      e.beforeId
    ), r.addLayer(
      {
        id: R.pointLayerId,
        type: "circle",
        source: c,
        filter: ["!", ["has", "point_count"]],
        paint: {
          "circle-pitch-alignment": p ? "viewport" : "map",
          "circle-pitch-scale": "map",
          // scale with camera distance regardless of viewport/biewport alignement
          // 'circle-color':  options.pointColor ?? clusterStyle[0].color,
          "circle-color": typeof e.pointColor == "string" ? e.pointColor : l.getColorHex(l.getBounds().min),
          "circle-radius": typeof e.pointRadius == "number" ? e.pointRadius : Array.isArray(e.pointRadius) ? b(e.pointRadius) : E[0].pointRadius * 0.75,
          "circle-opacity": w,
          ...u && {
            "circle-stroke-opacity": typeof d == "number" ? d : b(d),
            "circle-stroke-width": typeof m == "number" ? m : b(m),
            "circle-stroke-color": typeof v == "string" ? v : Z(v)
          }
        },
        minzoom: A,
        maxzoom: I
      },
      e.beforeId
    );
  } else {
    let E = typeof e.pointColor == "string" ? e.pointColor : Array.isArray(e.pointColor) ? e.pointColor.getColorHex(e.pointColor.getBounds().min) : he(), U = typeof e.pointRadius == "number" ? M ? b([
      { zoom: 0, value: e.pointRadius * 0.025 },
      { zoom: 2, value: e.pointRadius * 0.05 },
      { zoom: 4, value: e.pointRadius * 0.1 },
      { zoom: 8, value: e.pointRadius * 0.25 },
      { zoom: 16, value: e.pointRadius * 1 }
    ]) : e.pointRadius : Array.isArray(e.pointRadius) ? b(e.pointRadius) : M ? b([
      { zoom: 0, value: t * 0.05 },
      { zoom: 2, value: t * 0.1 },
      { zoom: 4, value: t * 0.2 },
      { zoom: 8, value: t * 0.5 },
      { zoom: 16, value: t * 1 }
    ]) : t;
    if (e.property && Array.isArray(e.pointColor)) {
      const j = Array.from({ length: n }, (W, J) => {
        const q = i.min + J * (i.max - i.min) / (n - 1);
        return {
          value: q,
          pointRadius: typeof e.pointRadius == "number" ? e.pointRadius : t + (o - t) * (J / (n - 1)) ** 0.5,
          color: typeof e.pointColor == "string" ? e.pointColor : l.getColorHex(q)
        };
      });
      E = Pe(j, e.property), U = Oe(j, e.property, M);
    }
    r.addLayer(
      {
        id: R.pointLayerId,
        type: "circle",
        source: c,
        layout: {
          // Contrary to labels, we want to see the small one in front. Weirdly "circle-sort-key" works in the opposite direction as "symbol-sort-key".
          "circle-sort-key": e.property ? ["/", 1, ["get", e.property]] : 0
        },
        paint: {
          "circle-pitch-alignment": p ? "viewport" : "map",
          "circle-pitch-scale": "map",
          // scale with camera distance regardless of viewport/biewport alignement
          "circle-color": E,
          "circle-opacity": w,
          "circle-radius": U,
          ...u && {
            "circle-stroke-opacity": typeof d == "number" ? d : b(d),
            "circle-stroke-width": typeof m == "number" ? m : b(m),
            "circle-stroke-color": typeof v == "string" ? v : Z(v)
          }
        },
        minzoom: A,
        maxzoom: I
      },
      e.beforeId
    );
  }
  if (s !== !1 && (e.cluster || e.property)) {
    R.labelLayerId = `${h}_label`;
    const E = e.labelColor ?? "#fff", U = e.labelSize ?? 12;
    r.addLayer(
      {
        id: R.labelLayerId,
        type: "symbol",
        source: c,
        filter: ["has", e.cluster ? "point_count" : e.property],
        layout: {
          "text-field": e.cluster ? "{point_count_abbreviated}" : `{${e.property}}`,
          "text-font": ["Noto Sans Regular"],
          "text-size": U,
          "text-pitch-alignment": p ? "viewport" : "map",
          "symbol-sort-key": ["/", 1, ["get", e.cluster ? "point_count" : e.property]]
          // so that the largest value goes on top
        },
        paint: {
          "text-color": E,
          "text-opacity": w
        },
        minzoom: A,
        maxzoom: I
      },
      e.beforeId
    );
  }
  return R;
}
function Lo(r, e) {
  if (e.layerId && r.getLayer(e.layerId))
    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
  const t = e.sourceId ?? te(), o = e.layerId ?? oe(), a = e.minzoom ?? 0, n = e.maxzoom ?? 23, l = e.zoomCompensation ?? !0, i = e.opacity ?? [
    { zoom: a, value: 0 },
    { zoom: a + 0.25, value: 1 },
    { zoom: n - 0.25, value: 1 },
    { zoom: n, value: 0 }
  ];
  let c = Array.isArray(e.colorRamp) ? e.colorRamp : Je.TURBO.transparentStart();
  const h = c.getBounds();
  (h.min !== 0 || h.max !== 1) && (c = c.scale(0, 1)), c.hasTransparentStart() || (c = c.transparentStart());
  const s = e.intensity ?? [
    { zoom: 0, value: 0.01 },
    { zoom: 4, value: 0.2 },
    { zoom: 16, value: 1 }
  ], p = e.property ?? null, u = e.weight ?? 1;
  let d = 1;
  p ? typeof u == "number" ? (d = u, typeof e.weight == "number" && console.warn(
    "The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`"
  )) : Array.isArray(u) ? d = po(u, p) : console.warn(
    "The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`"
  ) : typeof u == "number" ? d = u : Array.isArray(u) && console.warn("The options `.propertyValueWeights` can only be used when `.property` is provided.");
  const m = [
    { zoom: 0, value: 50 * 0.025 },
    { zoom: 2, value: 50 * 0.05 },
    { zoom: 4, value: 50 * 0.1 },
    { zoom: 8, value: 50 * 0.25 },
    { zoom: 16, value: 50 }
  ], v = e.radius ?? (l ? m : 10);
  let w = 1;
  typeof v == "number" ? w = v : Array.isArray(v) && "zoom" in v[0] ? w = b(v) : p && Array.isArray(v) && "propertyValue" in v[0] ? w = ho(v, p, l) : !p && Array.isArray(v) && "propertyValue" in v[0] ? (w = b(m), console.warn("The option `.radius` can only be property-driven if the option `.property` is provided.")) : w = b(m);
  const M = {
    heatmapLayerId: o,
    heatmapSourceId: t
  };
  if (e.data && !r.getSource(t)) {
    let A = e.data;
    typeof A == "string" && ee(A) && (A = `https://api.maptiler.com/data/${A}/features.json?key=${N.apiKey}`), r.addSource(t, {
      type: "geojson",
      data: A
    });
  }
  return r.addLayer({
    id: o,
    type: "heatmap",
    source: t,
    minzoom: a,
    maxzoom: n,
    paint: {
      "heatmap-weight": d,
      "heatmap-intensity": typeof s == "number" ? s : b(s),
      "heatmap-color": mo(c),
      "heatmap-radius": w,
      "heatmap-opacity": typeof i == "number" ? i : b(i)
    }
  }), M;
}
const Zo = {
  addPolyline: fo,
  addPolygon: yo,
  addPoint: vo,
  addHeatmap: Lo
};
Ut();
function Wo() {
  return _t.version;
}
const Yo = f.Map, Jo = f.Marker, qo = f.Popup, Xo = f.Style, Qo = f.CanvasSource, er = f.GeoJSONSource, tr = f.ImageSource, or = f.RasterTileSource, rr = f.RasterDEMTileSource, ar = f.VectorTileSource, nr = f.VideoSource, lr = f.NavigationControl, ir = f.GeolocateControl, sr = f.AttributionControl, cr = f.LogoControl, ur = f.ScaleControl, pr = f.FullscreenControl, dr = f.TerrainControl, hr = f.BoxZoomHandler, mr = f.ScrollZoomHandler, fr = f.CooperativeGesturesHandler, gr = f.KeyboardHandler, yr = f.TwoFingersTouchPitchHandler, vr = f.MapWheelEvent, Lr = f.MapTouchEvent, Ar = f.MapMouseEvent, Cr = f.config, wr = f.getVersion, {
  setRTLTextPlugin: Sr,
  getRTLTextPluginStatus: br,
  LngLat: Tr,
  LngLatBounds: Er,
  MercatorCoordinate: Ir,
  Evented: Rr,
  AJAXError: _r,
  prewarm: xr,
  clearPrewarmedResources: Nr,
  Hash: Mr,
  Point: Pr,
  EdgeInsets: Or,
  DragRotateHandler: kr,
  DragPanHandler: Fr,
  TwoFingersTouchZoomRotateHandler: Br,
  DoubleClickZoomHandler: zr,
  TwoFingersTouchZoomHandler: Ur,
  TwoFingersTouchRotateHandler: Dr,
  getWorkerCount: Hr,
  setWorkerCount: Gr,
  getMaxParallelImageRequests: Vr,
  setMaxParallelImageRequests: jr,
  getWorkerUrl: $r,
  setWorkerUrl: Kr,
  addSourceType: Zr,
  importScriptInWorkers: Wr,
  addProtocol: Yr,
  removeProtocol: Jr
} = f;
export {
  _r as AJAXError,
  Bo as AttributionControl,
  sr as AttributionControlMLGL,
  Uo as BoxZoomHandler,
  hr as BoxZoomHandlerMLGL,
  xo as CanvasSource,
  Qo as CanvasSourceMLGL,
  g as ColorRamp,
  Je as ColorRampCollection,
  Ho as CooperativeGesturesHandler,
  fr as CooperativeGesturesHandlerMLGL,
  zr as DoubleClickZoomHandler,
  Fr as DragPanHandler,
  kr as DragRotateHandler,
  Or as EdgeInsets,
  Rr as Evented,
  Wt as FullscreenControl,
  pr as FullscreenControlMLGL,
  No as GeoJSONSource,
  er as GeoJSONSourceMLGL,
  $t as GeolocateControl,
  ir as GeolocateControlMLGL,
  Qt as GeolocationType,
  Mr as Hash,
  Mo as ImageSource,
  tr as ImageSourceMLGL,
  Go as KeyboardHandler,
  gr as KeyboardHandlerMLGL,
  C as Language,
  Qr as LanguageGeocoding,
  Tr as LngLat,
  Er as LngLatBounds,
  Kt as LogoControl,
  cr as LogoControlMLGL,
  eo as Map,
  Yo as MapMLGL,
  Ko as MapMouseEvent,
  Ar as MapMouseEventMLGL,
  ea as MapStyle,
  ta as MapStyleVariant,
  $o as MapTouchEvent,
  Lr as MapTouchEventMLGL,
  jo as MapWheelEvent,
  vr as MapWheelEventMLGL,
  Xt as MaptilerGeolocateControl,
  we as MaptilerLogoControl,
  Jt as MaptilerNavigationControl,
  Yt as MaptilerTerrainControl,
  Eo as Marker,
  Jo as MarkerMLGL,
  Ir as MercatorCoordinate,
  lr as NavigationControMLGL,
  jt as NavigationControl,
  Pr as Point,
  Ro as Popup,
  qo as PopupMLGL,
  Oo as RasterDEMTileSource,
  rr as RasterDEMTileSourceMLGL,
  Po as RasterTileSource,
  or as RasterTileSourceMLGL,
  oa as ReferenceMapStyle,
  Zt as ScaleControl,
  ur as ScaleControlMLGL,
  Do as ScrollZoomHandler,
  mr as ScrollZoomHandlerMLGL,
  Mt as SdkConfig,
  ra as ServiceError,
  _o as Style,
  Xo as StyleMLGL,
  dr as TerrainControMLGL,
  zo as TerrainControl,
  Vo as TwoFingersTouchPitchHandler,
  yr as TwoFingersTouchPitchHandlerMLGL,
  Dr as TwoFingersTouchRotateHandler,
  Ur as TwoFingersTouchZoomHandler,
  Br as TwoFingersTouchZoomRotateHandler,
  ko as VectorTileSource,
  ar as VectorTileSourceMLGL,
  Fo as VideoSource,
  nr as VideoSourceMLGL,
  Yr as addProtocol,
  Zr as addSourceType,
  aa as bufferToPixelDataBrowser,
  na as circumferenceAtLatitude,
  Nr as clearPrewarmedResources,
  N as config,
  Cr as configMLGL,
  la as coordinates,
  ia as data,
  sa as elevation,
  ca as expandMapStyle,
  ua as geocoding,
  pa as geolocation,
  da as getAutoLanguageGeocoding,
  ye as getBrowserLanguage,
  ha as getBufferToPixelDataParser,
  wr as getMapLibreVersion,
  Vr as getMaxParallelImageRequests,
  br as getRTLTextPluginStatus,
  ma as getTileCache,
  Wo as getVersion,
  Hr as getWorkerCount,
  $r as getWorkerUrl,
  Ve as gpx,
  so as gpxOrKml,
  Ge as hasChildNodeWithName,
  Zo as helpers,
  Wr as importScriptInWorkers,
  ge as isLanguageSupported,
  je as kml,
  fa as mapStylePresetList,
  ga as math,
  ya as misc,
  xr as prewarm,
  Jr as removeProtocol,
  jr as setMaxParallelImageRequests,
  Sr as setRTLTextPlugin,
  Gr as setWorkerCount,
  Kr as setWorkerUrl,
  va as staticMaps,
  pe as str2xml,
  La as styleToStyle,
  Ee as xml2str
};
//# sourceMappingURL=maptiler-sdk.mjs.map
